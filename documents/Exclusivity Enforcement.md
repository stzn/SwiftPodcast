# Exclusivity Enforcementとは？

- [Exclusivity Enforcementとは？](#exclusivity-enforcementとは)
  - [問題点(Swift3時代)](#問題点swift3時代)
  - [「瞬間的」ではないアクセスを排除すれば良い？](#瞬間的ではないアクセスを排除すれば良い)
  - [解決策](#解決策)
  - [値型でのルール](#値型でのルール)
  - [参考](#参考)

同じ変数(※)への2つのアクセスは、両方のアクセスが読み取りでない限り重複することはできない、というルール。

※ グローバル変数、ローカル変数、クラスおよび構造体のプロパティなど、あらゆる種類の可変メモリを意味する。

Swift3ではこれが導入されていなかった。下記に起きていた問題と解決策の概要を記載する。

## 問題点(Swift3時代)

基本的なレベルでは、Swiftは可変なメモリに直接アクセスできる命令型プログラミング(imperative language)。多くのメモリにアクセスする機能は「瞬間的」である。「瞬間的」とは、現在のスレッドという観点で、その操作が他のコードに干渉されることなく完了するということ。例えば、格納プロパティに値を代入する場合、現在の値が新しい値に置き換えるなど。  
他のコードが恣意的に同時に実行できないので、2つの瞬間的なアクセスがお互いに重なるということはない(同時並行処理は別の問題)。こうすることで挙動の推論やコンパイラの最適化がとても簡単になる。

しかし、全てのアクセスが瞬間的ではない。例えば格納プロパティの`mutating`メソッドを呼ぶと、そのプロパティに長い期間アクセスすることになり、`self`はそのプロパティを参照するもう一つの方法になる。このプロパティへのアクセス中にメソッド内の全コードが実行される。そのため。同じプロパティに再度アクセスしようとすると、そのアクセスは重複することになる。

下記は問題となるコードの例:

```swift
// シンプルなグローバル変数があるとする
var global: Int = 0
var total: Int = 0

extension Int {
    // mutatingメソッドはメソッドの実行中に呼び出された変数にアクセスする
    mutating func increaseByGlobal() {
        // 任意のアクセスはその変数への重複アクセスになる

        total += self // 変数totalにtotalとselfの両方でアクセスする可能性がある
        self += global // 変数globalにglobalとselfの両方でアクセスする可能性がある
    }
}
```
上記の例は内部的な低レベルでのセマンティクスは変わらないが、高レベルでのプログラマの理解はほぼ間違いなく変わってしまう。例えば、`self`が`global`だったら、突然`global`が２倍になったように見えてしまう。これは、このメソッドを保守している人にとって非常に重要な情報。この人は、同等と思われる方法でコードを再配置したくなるかもしれない。


重複の可能性は、言語がこのメソッドの読み込み/書き込みについて悲観的な仮定をしなければならないことを意味する。 たとえば、次のコードは一見冗長な負荷を回避しているが、重複しているため実際にはそうではない:

```swift
let value = self
total += value
self = value + global
```

これは余計な読み込みが発生するだけだが、もっと複雑な場合は不必要なコピーが発生することもある。

```swift
extension Array {
    mutating func modifyElements(_ closure: (inout Element) -> ()) {
        var i = startIndex
        while i != endIndex {
            closure(&self[i])
            i = index(after: i)
        }
    }
}
```

一見正しそうに見えるが、クロージャ内で`self`は変更することができ、`i`が突然不正なindexになってしまい、予期せぬ挙動につながる可能性がある。現実では起きかもしれないが、こういう可能性を考慮すると重要な最適化を実行することができない。例えば、COWのチェックをループの内側から外側に引き上げることができるが、上記の例では`self`がクロージャ内で変更もしくはコピーされる可能性があるためできない。

これは`inout`でも同じことが言える。

```swift
open class Person {
    open var title: String
}

func collectTitles(people: [Person], into set: inout Set<String>) {
    for person in people {
        set.insert(person.title)
    }
}
```

これは`String`の`Set`を変更していると同時に`class`のメソッドを呼び出している。しかし、これは`open`なため、コンパイラは実装がどうなっているのかわからないため、悲観的な推測をするしかできない。

## 「瞬間的」ではないアクセスを排除すれば良い？

2つの理由からそうすれば良いというわけではない。もし`mutating`メソッドで`self`にアクセスできない場合、一時的コピーにアクセスし、メソッド完了時に元のストレージに再代入する必要がある。例えば:

```swift
var numbers = [Int]()
numbers.appendABunchOfStuff()
```

は、下記のように変換される(イメージ)

```swift
struct Array numbers = _Array_init();
_Array_appendABunchOfStuff(&numbers);
```

「瞬間的」ではないアクセスを排除した場合はこうなる:

```swift
struct Array numbers = _Array_init();
struct Array temp = _Array_copy(numbers);
_Array_appendABunchOfStuff(&temp);
_Array_assign(&numbers, temp);
```

これはパフォーマンスが良くない。余計なコピーが発生する。`Array`などのCOWが使われている型の場合、バッファへの参照も強制的にコピーされてしまう。  
また、仮に`numbers`がグローバル変数などでどこからでもアクセスできる場合、`temp`への変更中にアクセスしてもその変更は反映されておらず、使う側に大きな混乱をもたらす可能性がある。

## 解決策

アクセスが瞬間的でない可能性があることを受け入れる必要がある。つまり、プログラマは、同じ変数への重複アクセスを引き起こすコードを書くことができる。現在、これが起こることを許可し、結果に耐えるために最善を尽くしている。一般に、コストは非常に複雑でパフォーマンスが低下する。

これはコンパイラの最適化の観点でも、言語の進化という観点でも大きな影響を与え続けている。

同じ変数への2つのアクセスは、両方のアクセスが読み取りでない限り、オーバーラップできないというルールをSwiftに追加する必要がある。「変数」とは、グローバル変数、ローカル変数、クラスおよび構造体のプロパティなど、あらゆる種類の可変メモリを意味する。

このルールは、変数の種類に応じて、可能な限り強力に適用する必要がある:

- ローカル変数、`inout`パラメータ、および`struct`プロパティは、通常、ルールを静的に適用できる。コンパイラは、変数へのすべてのアクセスを分析し、競合が検出された場合にエラーを発行できる
- クラスプロパティとグローバル変数は、ルールを動的に適用する必要がある。 ランタイムは、進行中のアクセスを追跡し、競合を報告できる。ローカル変数は、クロージャにキャプチャされるときに動的な適用を強制する必要がある場合がある
- 安全でないポインタは、アクティブな強制を使用しない。ルールに従うかどうかはプログラマの責務
- `let`バインディングや`let`プロパティなどの不変メモリは、すべてのアクセスは読み取りであるため必要ない

```swift
var x = 0, y = 0

// ⭕️　競合しない 両方のxは読み取り。
// 両方とも瞬間的に完了するのでアクセスが重複せず競合しない。
// 瞬間的でなくても、両方のxは読み取りなので競合しない。
let z = x + x

// ⭕️　競合しない 右側は瞬間的に完了する読み取りのxで、書き込み(代入される)側のxも
// 瞬間的に完了するのでアクセスが重複せず競合しない。
x = x

// ⭕️　競合しない 右側は瞬間的に完了する読み取りのx。 オペレータを呼び出すのは、inout引数としてxを渡すのと同じ。
// これはメソッド呼び出し中の書き込みアクセスだが、右側が評価されてメソッドが実行される直前までアクセスが始まらない
// そのためアクセスが重複せず競合しない。
x += x

// ❌　競合 inout引数としてxを渡すのはメソッドの呼び出し中は書き込みアクセス。
// 同じ変数を2度渡すことは1つの変数への2つの重複した書き込みアクセスになるので競合
swap(&x, &x)

extension Int {
  mutating func assignResultOf(_ function: () -> Int) {
    self = function()  
  }
}

// ❌　競合 値型のmutatingメソッドはメソッドの呼び出し中は書き込みアクセス。
// クロージャ内のxの読み取りはそのメソッドが実行中に評価される。
// つまり、xへのアクセスが重複していることになるので競合
x.assignResultOf { x + 1 }
```

## 値型でのルール

値型でメソッドを呼び出すことは、値全体へのアクセス。`mutating`メソッドの場合は書き込み、それ以外の場合は読み取りになる。これは、メソッドが値の任意の部分を読み書きする可能性があると想定する必要があるため。「このメソッドはこれらのプロパティのみを使用する」などのルールを形式化しようとすると、言語が非常に複雑になる。

同様の理由で、値型に計算プロパティまたは`subscript`を使用することは、通常、値全体へのアクセスとして扱われる必要がある。アクセスが読み取りか書き込みかは、プロパティ/`subscript`の使用方法と、`getter`または`setter`のどちらが変更されているかによって異なる。

構造体のさまざまな格納プロパティまたはタプルのさまざまな要素へのアクセスは重複できる。ただし、値型の一部を変更するには値全体への排他的アクセスが必要で、そのアクセスを取得すること自体が重複アクセスを防ぐ可能性があることに注意。例えば:

```swift
struct Pair {
    var x: Int
    var y: Int
}

class Paired {
    var pair = Pair(x: 0, y: 0)
}

let object = Paired()
swap(&object.pair.x, &object.pair.y)
```

ここで、最初の引数の`object.pair`への書き込みアクセスを開始すると、プロパティに動的な排他強制が使用されるため、2番目の引数の`object.pair`への書き込みアクセスが成功しなくなる。これらのアクセスがプロパティのさまざまなサブコンポーネントを変更しているという事実を動的な排他強制の際に解決しようとすると、追加のパフォーマンスコストと実装の複雑さの両方の観点から、大変なことになるため行なわない。

しかし、`object.pair`を`inout`引数に渡すというワークアラウンドがある。

```swift
func modifying<T>(_ value: inout T, _ function: (inout T) -> ()) {
    function(&value)
}

modifying(&object.pair) { pair in swap(&pair.x, &pair.y) }
```

これが機能するのは、`object.pair`へのアクセスが1つだけであり、`inout`パラメーターがそのストレージにバインドされると、関数内のパラメータへのアクセスで純粋に静的な排他強制を使用できるため。(このような回避策が必要になることはめったにないと予想される。)

2つの異なるプロパティは、両方が格納プロパティであることがわかっている場合にのみ、競合しないと見なすことができることに注意。これは、例えば、復元力のある値型の異なるプロパティへの重複アクセスが許可されないことを意味する。これは、プログラマにとって重大な問題になるとは思われない。

## 参考

- [Enforce Exclusive Access to Memory](https://github.com/apple/swift-evolution/blob/main/proposals/0176-enforce-exclusive-access-to-memory.md)
- [Swift 5 Exclusivity Enforcement](https://www.swift.org/blog/swift-5-exclusivity/)
