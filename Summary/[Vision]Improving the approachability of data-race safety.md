# データ競合安全性の理解しやすさの向上

原文: [Improving the approachability of data-race safety](https://github.com/swiftlang/swift-evolution/blob/main/visions/approachable-concurrency.md)

注: このドキュメントは Language Steering Group が掲げた目標や基本的なアプローチを記載したものであり、具体的なプロポーザルを事前に承認するものではない。そのため、プロポーザルの過程でこのドキュメントの内容から変更される可能性がある。

## 背景

Swiftの組み込みの並行性サポートには3つの目標がある:

1. 低レイヤーのデータ競合に対してまでメモリ安全性の保証を拡張すること
2. 並行性を導入していないコードに対して段階的な開示(progressive disclosure)を維持し、並行性の基本的な使い方をシンプルかつ簡単にすること
3. パフォーマンスを向上させるための高度な並行性を自然な形で実行し、合理的にすること

Swift 6 では、1 の目標を満たす正確性を提供している。しかし、それによって 2 の目標を犠牲にしていることがあり、導入を難しくしている可能性がある。そこで、数年の経験を経た今、この問題に対処するためにできることを検討する。

このドキュメントでは、使いやすさを向上させる可能性のある方法をいくつか示し、2つのユースケースに焦点を当てる:

1. プログラマーが並行性を使うことを全く意図していない場合
2. Swift Concurrency以前の並行性ライブラリを使用している既存のコードベースを適応させたい場合

このビジョンの重要な点は、パフォーマンスのために並行性が必要ではないプロジェクト(UI アプリケーションやスクリプトなど)に対して、必要な並行性のアノテーションを大幅に削減する(一方で、必要になったときに並行性を導入しやすくする)ことである。

それを達成するために、段階的な開示には3つの段階があると考える:

1. 逐次的な単一スレッド(メインアクター)のコードを書く
実行時の並行性はないため、データ競合のリスクはない
2. データ競合のリスクがない非同期コードを書く
ライブラリのAPIなどを使って基本的なasync/awaitを導入し始める。この段階では、共有可変状態を使用する必要はなく、データ競合のリスクはまだない
3. パフォーマンスを向上させるために並行性を導入する
より良いパフォーマンスを得るために、メインアクターから(TaskやStructured Concurrencyなどによって)作業を協調スレッドプールにオフロードし、並行性を活用し始める。コンパイラのエラーに頼りながらデータ競合を防ぐ

## 今後の方向性

### 逐次コードで誤検出されるデータ競合安全性エラーを減らす

多くのコードは事実上「シングルスレッド」。メインアクターで実行を開始し、コードの一部で並行性を使用しない限り、逐次的に実行され、データ競合のリスクはなく、並行性に関するエラーはすべて誤検知である。

この誤検知を減らすために、**逐次的に実行される部分は「シングルスレッド」である**と想定するようにする。こうすることで、Swiftは、逐次的に実行されることを認識し、データ競合がないと証明する。さらに、並行性を使用している部分からシングルスレッドの部分へのアクセスを防ぐ。

#### 現在の Swift 6 におけるシングルスレッドコードの問題

現状: デフォルトで並行性を前提としている

影響:
- 至る所にメインアクターを書かなければならない
- 並行性についての学習コストがすべてのプログラマーにかかる
- アクター隔離された値をプロトコルに準拠させるのが難しく、ジェネリックコードを書くのが難しい

シングルスレッドコードをモデル化する最も簡単で最適な方法は、グローバルアクターを使用すること。すべてのプログラムはメインアクターで実行を開始し、プログラム内のすべてがメインアクターに隔離されている場合、並行性エラーは発生しないはず。

#### モジュールのデフォルトをシングルスレッドにする

これにより、モジュール内のアノテーションのないコードのデフォルトの隔離ルールが変更される。非隔離状態となり、並行性が前提の場合のような対処は必要なく、暗黙的にメインアクターに隔離されることになる。他のモジュールからインポートされたコードは、現在のモジュールのデフォルト設定の影響を受けない。並行性が必要な場合は、関数や型を nonisolated として明示的にマークするか([SE-0449](https://github.com/swiftlang/swift-evolution/blob/main/proposals/0449-nonisolated-for-global-actor-cutoff.md))、メインアクター隔離をデフォルトとしないモジュールで定義できる

#### executable モジュールのデフォルト

executable ターゲットは、メインアクターを中心に構成される傾向があります。コマンドラインツールやスクリプトはすべてメインアクター上で開始され、明示的に並行性を導入する処理を行わない限り、メインアクター上で実行を続ける。同様に、ほとんどのUIプログラムは、メインアクターを特権化するシングルスレッドの UI フレームワークを多用している。このような種類のコードは、デフォルトでシングルスレッドモデルを採用することで大幅に改善される。

#### ライブラリモジュールのデフォルト

ライブラリターゲットは、現在の Swift 6 と同様に、デフォルトで非隔離のままにすることが妥当。ほとんどのライブラリ関数は、任意のコンテキストから使用可能であることを意図しており、通常はグローバルや共有の可変状態を使用することを避ける。

※ UI ライブラリや、executable プロジェクト内でのコード整理のために使用される場合など、メインアクターデフォルトにするほうが妥当な場合もある

#### 言語の方言が生まれてしまうリスク

モジュールごとのデフォルトの隔離方法を指定する設定を追加することは、新しい恒久的な言語の方言を導入することになる。
※ upcoming feature flag もある種の言語の方言だが、最終的に将来の言語モードに組み込まれることが期待されているため「一時的」とみなされる。

これはさまざまな問題が発生する可能性がある

例えば
- 関数がどの隔離ドメインで実行されているかを知る必要があることは多く、モジュールごとの設定によって変わってくることになる(ただし、現状でも難しい)
- シングルスレッドのモジュールから非隔離のモジュールにコードを移動する場合にさまざまなエラーに遭遇する(IDEがシングルスレッドであることを明示するなどのサポートが必要かもしれない)

こういった懸念はあるものの、総合的にこのコストは控えめで、管理可能であると考える

### プロトコルへのisolated な準拠(isolated conformance)

現在の Swift 6 では、要件が同期的でも、パラメータが `Sendable` でない場合でも、`nonisolated` であることを要求されることが多い。これがグローバルアクター型やアクターの `nonisolated` なプロトコルへの準拠を難しくしている。このことは、並行性を導入したコードでは重要だが、シングルスレッドのプログラムでは誤検知の一般的な原因となっている。そしてこれに対する良い解決策がない(`assumeIsolated`などが必要になる)

関数値の場合はさまざまな対応をしてきた:

- `() -> Bool`は、現在の隔離ドメインに属することを示す。異なる隔離ドメインに渡すことはできないため、明示する必要がない
- `@MainActor () -> Bool`は、メインアクター(特定のグローバルアクター)に隔離されていることを示す。これに当てはまる関数は、nonisolated か 指定されたアクターに隔離されているかのどちらかで、Swift は、呼び出し時に無条件で指定されたアクターに隔離されているものとして扱う
- `@isolated(any) () -> Bool`は、動的に特定の隔離ドメインに属している可能性を示す。これに当てはまる関数は任意のドメインに隔離される可能性があるため、呼び出し側でそれに対応する準備が必要

これをプロトコルにも適用することで、プロトコルの準拠をより柔軟にすることができる。

- プロトコルへの準拠が現在の隔離ドメインからのみ使用することを意図している場合、現在のコンテキストがそのドメインに属している持っている限り、実装が何らかの隔離を必要とするかどうかは実際には重要ではない
- プロトコルの実装が特定のグローバルアクターに隔離される可能性があることがわかっている場合、プロトコル要件がそのActorに隔離されて宣言されているかのように、プロトコルに準拠したメソッドなどを使用するたびに対処できる
- `@isolated(any)` 関数値で既に行っているのと同じように、動的に隔離することもできる

シングルスレッドモデルで最も重要なのは、グローバルアクターにisolated な準拠を表現できること。型がグローバルアクターに隔離されている場合、そのメソッドはデフォルトで隔離される。通常、こうしたメソッドは、nonisolated なプロトコルの要件としては不正である。しかし、グローバルアクターに隔離されたものとして扱うことで、単純に準拠させることができます。

isolated な準拠は、nonisolated な準拠よりも柔軟性が低い。例えば、nonisolated モジュールからのジェネリック型と関数は、依然として nonisolated な準拠が要求されるため、isolated にしか準拠していない型でそれらを呼び出せない。一方で、シングルスレッドモジュールのジェネリック型と関数は、モジュールのデフォルトのグローバルアクターに隔離されるため、isolated な準拠を自由に使用できる。

isolated な準拠と nonisolated な準拠の両方で動作できるジェネリック関数は、isolated な準拠を受け入れられることを宣言する必要がある。その場合は「NonSendable準拠」のように現在の隔離ドメインでしか使用できないように制限される。

この設計はまだ開発中であり、解決すべき詳細が多くあるが、この機能が、特にグローバルアクター隔離型に関して、Swift のジェネリックシステムと隔離型との相互作用の問題を解決する可能性について期待している。

### isolated なサブクラスとオーバーライド

データ競合の安全性を実現するため、Swift 6 は、クラスに特有のさまざまな問題を診断する必要がある

- クラスとそのスーパークラスの Sendability が一致しなければならない(例外: すべてのスーパークラスの格納プロパティが Sendable であれば継承可能。現状 `NSObject` のみ)
- クラスが `Sendable` であり、グローバルアクターに隔離されない場合、その格納プロパティはすべて `Sendable` でなければならない
- クラスがグローバルアクターに隔離される場合、そのスーパークラスは nonisolated か、同じグローバルアクターに隔離されていなければならない
- オーバーライドは、オーバーライド先の隔離ドメインと一致しているか

実際にはメインアクター以外のグローバルアクターをほとんど使用しないため、ほとんど影響を与えない。したがって、ここでの唯一の重大な誤検知は、オーバーライドに関する制限である。

NonSendable なサブクラスは、グローバルアクターに隔離されているスーパークラスを継承できる([SE-0434](https://github.com/swiftlang/swift-evolution/blob/main/proposals/0434-global-actor-isolated-types-usability.md))。NonSendable でグローバルアクターに隔離されているため、オーバーライドを制限する必要はないはず。ただし、現在の Swift 6 では制限されている。これはサブクラスのイニシャライザに制限を課すことで改善できるはず(小規模な破壊的変更は発生する可能性がある)。

NonSendable なサブクラスに継承されたグローバルアクターに隔離されているスーパークラスにはこれができない。nonisolated メソッドの isolated なオーバーライドを安全に実行するためには、サブクラスへの参照をそのセンダブルなスーパークラス型に変換できないようにする必要がある。これは有用性に疑問があるため、情報を集めて再検討する。

### 非同期の基本的なコードの導入を容易にする

現状、nonisolated async 関数はアクターのエグゼキュータ上で実行されない([SE-0338](https://github.com/hborla/swift-evolution/blob/async-function-isolation/proposals/0338-clarify-execution-non-actor-async.md))。これはアクター上で予期せず重い処理が実行されることによる遅延を防ぐためである。

しかし、これは基本的な非同期コードを書くことを難しくし、段階的な開示を損なうことがわかってきた。例えば、メインアクターから NonSendable の引数を渡すと常にエラーが発生する。これに対処するために、多くのライブラリ API は `isolated` パラメータを導入した。

また、この現在の実行セマンティクスは、sync 関数と async 関数で `nonisolated` の意味が大きく異なるため、プログラマの理解を難しくしている。

nonisolated sync 関数: 常に呼び出し元の隔離ドメインで実行
nonisolated async 関数: (アクターが存在する場合)常に呼び出し元のアクターから切り離されて実行

これにより、基本的な非同期コードを書く場合でも、アクターの隔離とasync/awaitの中断する機能の2つのことを考えなければならない。

そこで、nonisolated async 関数のデフォルトの実行セマンティクスを、呼び出し元の隔離ドメインで実行するように変更することで、段階的な開示がより容易になる。nonisolated async 関数が呼び出し元に隔離ドメインを超えず、引数や戻り値のデータ競合安全性チェックが不要となり、多くの基本的な非同期コードは、アクター隔離を意識せずに書けるようになる。

アクターから切り離して実行したい場合は、`@execution(concurrent)`が使える。

ただし、現在の実行セマンティクスが導入されて数年が経過しており、モジュールのビルド設定を理解しないと nonisolated async 関数の実行セマンティクスを理解するのは難しく、望ましくない中間状態を作り出す。しかし、これは慎重な移行設計をすることで一部を緩和することができる。

このセクションの内容に関する詳細は[SE-0461](https://github.com/swiftlang/swift-evolution/blob/main/proposals/0461-async-function-isolation.md)を参照。

### データ競合安全性への段階的な移行を容易にする

Swift 6 のデータ競合安全性モデルは、Swift Concurrency 以前の並行性ライブラリを使用してきた経験豊富なプログラマーにとって大きな変更となる。さらに、そうしたライブラリ上に構築された多くの既存の大規模コードベースがあり、これらのコードベースを最新の並行性機能を活用し、静的データ競合安全性を有効にするには、大きな努力が必要となる。そこで、既存のコードベースでデータ競合安全性を有効にするために必要な労力を軽減することを目指す。

#### 同期コードと非同期コードの橋渡し

既存のコードベースに async/await を導入することは、言語が同期コードと非同期コードを橋渡しするツールを提供していないため、段階的に行うことが難しい。非同期タスクを実行するためにUnstructured Taskを利用できるが、同期コードが非同期処理から結果を必要とするなど、適さない場合もある。また、非同期未対応の関数が依存ライブラリ内に存在する場合など、非同期呼び出しをコード全体に展開するのは難しくなることが多い。特に、メインアクターを大量に使用するプログラムでは、アクターの外部からはすべての相互作用を非同期で行う必要があるため、async/await を使用せざるを得ない。

また、Dispatchなどの他の並行性ライブラリは、`DispatchQueue.asyncAndWait` など、非同期タスクを待機するための限定的なツールセットを提供している。これらのツールには、システムリソースを占有し、デッドロックを引き起こす可能性があるなど、深刻なトレードオフがあるが、プロジェクトによっては不可欠な機能を提供する。これを言語で表現できることが重要である。これらの機能を提供したとしても、デッドロックに関しては、言語モデルがアクターのリエントラントを許可し、アクター上にエンキューされたタスクが厳密なFIFOで実行される保証がないため、リスクを軽減できる。

#### 厳密でない並行性コンテキストからのアクター隔離違反による実行時アサーションの軽減

[SE-0423](https://github.com/swiftlang/swift-evolution/blob/main/proposals/0423-dynamic-actor-isolation.md)により、コンパイラは、データ競合安全なコードと安全でないコードの境界に動的なアクター隔離のアサーションを挿入するようになった。これは、まだ Swift 6 に移行していない依存しているライブラリ内のアクター隔離違反を捉え、実装におけるデータ競合安全性の問題を特定する。不足している `@Sendable` アノテーションを特定するのに効果的だが、クライアントがライブラリより先に移行すると実行時クラッシュが発生するため Swift 6 の採用を困難にする。

さらに、これらの一部は誤検知である。実行時チェックは関数の静的隔離に基づいて挿入されるが、関数は、アクターに隔離された可変状態にアクセスしない可能性がある。この場合、関数実装の分析に基づいて、動的チェックを単純に省略できる。

これ以外のチェックは妥当であり、このデータ競合を解決する正しい方法は、関数をアクター上で実行するか、アクターに隔離された状態へのアクセスを排除するように関数を変更することである。

言語がこれを支援する方法は2つある:

- 間違った隔離ドメインで直接関数を呼び出す代わりに、アクター上で関数を呼び出すジョブをエンキューする。これは、関数が結果を返さない場合にのみ機能する
- [SE-0297](https://github.com/swiftlang/swift-evolution/blob/main/proposals/0297-concurrency-objc.md)を使用して、Objective-Cのコンプリーションハンドラを `@Sendable` としてインポートして、コンパイラがコンプリーションハンドラでのアクター隔離された状態へのアクセスをチェックできるようにする(詳しくは[SE-0463](https://github.com/swiftlang/swift-evolution/blob/main/proposals/0463-sendable-completion-handlers.md)を参照)

### 自動移行

Swift 6 への移行とは異なり、このビジョンで説明されているソース互換性に影響を与える言語変更は、既存のコードのセマンティクスを保持しながら自動的に移行できる。このビジョンのソース互換性のない部分は、upcoming feature フラグの背後に配置され、メインアクターをデフォルトで推論するモジュールごとの設定を除いて、将来の 6.x 言語モードでデフォルトで有効になる。

コンパイラツールは、プログラマーが、個別にまたは将来の言語モード移行の一部として、これらのupcoming feature を有効にした場合、既存のプロジェクトを自動的に移行できる。プログラマーは、1つ以上のupcoming feature を有効にした、または一連の upcoming feature が有効になる特定の言語モードで「移行ビルド」することができ、コンパイラーがエラーを発することなく、またセマンティクスを変更することなく、ソースコードを変更できる。

### このビジョンに含まれないもの

このビジョンは、タスクの順序付けとアクターのリエントランシーに関する既存の課題をカバーしていない。これらは重要な問題であるが、より高度な並行性の使用においてより顕著な課題であり、これとは別に詳細な調査が必要である。

診断とドキュメントの改善も、このビジョンドキュメントではカバーされていない。すべての言語への提案は、言語設計の決定によって正確で実行可能なエラーメッセージが妨げられないよう、注意すべきである。加えて、診断とドキュメンテーションの変更は、Swift Evolution では管理されていない。これらの変更は、長期的なソース互換性とABIの制約に関わらないため、重厚な審査プロセスを経る必要はない。しかし、診断とドキュメンテーションは、並行性モデルをより理解しやすくするための非常に重要なツールであり、このビジョンの実装作業に含まれる。(例えば、[こちら](https://forums.swift.org/t/rfc-educational-notes-for-data-race-safety-errors/78003/6)や[こちら](https://forums.swift.org/t/surfacing-educational-notes-for-compiler-errors/78023)などで提案されている Educational note など)