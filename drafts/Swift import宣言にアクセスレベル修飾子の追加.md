# Swift import宣言にアクセスレベル修飾子の追加

- [Swift import宣言にアクセスレベル修飾子の追加](#swift-import宣言にアクセスレベル修飾子の追加)
  - [概要](#概要)
  - [内容](#内容)
    - [動機](#動機)
    - [提案内容](#提案内容)
    - [詳細](#詳細)
      - [インポートされたモジュールのアクセスレベルの宣言](#インポートされたモジュールのアクセスレベルの宣言)
      - [インポートされたモジュールへの参照に対する型チェック](#インポートされたモジュールへの参照に対する型チェック)
      - [推移的依存関係のロード](#推移的依存関係のロード)
      - [Swift5とSwift6におけるデフォルトのインポートアクセスレベル](#swift5とswift6におけるデフォルトのインポートアクセスレベル)
      - [インポート宣言上の他の属性との関係](#インポート宣言上の他の属性との関係)
    - [ソース互換性](#ソース互換性)
    - [ABI互換性](#abi互換性)
    - [導入の影響](#導入の影響)
    - [将来の検討事項](#将来の検討事項)
      - [レジリエントでないモジュールの依存性を隠す](#レジリエントでないモジュールの依存性を隠す)
    - [代替案](#代替案)
      - [\`@\_implementationOnly import\`\`](#_implementationonly-import)
      - [`open`インポートを公式の`@_exported`インポートとして使用する](#openインポートを公式の_exportedインポートとして使用する)
      - [APIでの使用から依存関係の可視性を推論する](#apiでの使用から依存関係の可視性を推論する)
  - [参考リンク](#参考リンク)
    - [Forums](#forums)
    - [プロポーザルドキュメント](#プロポーザルドキュメント)


## 概要

`import`宣言のアクセスレベル修飾子で依存関係の可視性(visibility)を宣言することで、どの宣言がインポートされたモジュールを参照できるかを強制することができる。ある依存関係は、ソースファイル、モジュール、パッケージ、またはすべてのクライアントにのみ見えるようにマークすることができる。これによって、クラスや関数などの宣言のアクセスレベルのおなじみの動作が、依存関係とインポートされた宣言にもたらされる。この機能は、クライアントから実装の詳細を隠すことができ、依存関係の「つきまとい」を管理するのに役立つ。

## 内容

### 動機

よい例として、外部のクライアントが内部の詳細に依存することを避けるために、publicとinternalのサービスを分離できることが挙げられる。Swiftはすでに、宣言に対するそれぞれの修飾子と型チェック時にその制約を強制する機能を持つアクセスレベルを提供しているが、依存関係のための同じ公式の機能は現在ない。

ライブラリの作者は、そのライブラリの依存関係のそれぞれに対して異なる意図を持っているかもしれない。つまり、いくつかはライブラリのクライアントに公開されることを想定しているが、その他のものはパッケージ、モジュール、またはソースファイルの内部の実装の詳細のためであるかもしれない。依存関係に作者の意図したアクセスレベルを強制する方法がないと、たとえそれが実装の詳細を意図していたとしても、public宣言からそれを参照することによって、ライブラリの依存関係をライブラリのクライアントに公開してしまうという間違いを犯しやすくなる。

すべてのライブラリの依存関係がライブラリのクライアントに見えるということは、コンパイラに必要以上の仕事をさせることにもなる。コンパイラは、ライブラリのクライアントをビルドするときに、クライアントをビルドするために実際には必要でない依存関係も含めて、ライブラリの依存関係をすべてロードしなければならない。

### 提案内容

この提案の中心は、現在のアクセスレベルロジックを拡張して、`import`宣言に既存の修飾子(`open`を除く)を宣言し、インポートされた宣言にアクセスレベルを適用することをサポートすることである。

たとえば、`DatabaseAdapter`モジュールがローカルモジュールの実装の詳細である場合を考えてみよう。これをクライアントに公開したくないので、`import`を`internal`とマークする。この場合、コンパイラは内部関数からの参照を許可するが、`public`関数からの参照は拒否する。

```swift
internal import DatabaseAdapter

internal func internalFunc() -> DatabaseAdapter.Entry {...} // Ok
public func publicFunc() -> DatabaseAdapter.Entry {...} // error: function cannot be declared public because its result uses an internal type
```

さらに、この提案は、ライブラリのクライアントがライブラリの依存関係をロードする必要があるとき、またはそれらがスキップできるときを決定するために、モジュールを構成するすべてのソースファイルの各`import`宣言で宣言されたアクセスレベルを使用する。ソースの互換性とベストプラクティスのバランスをとるために、提案するデフォルトの`import`は、Swift 5 では `public`、Swift 6 モードでは `internal` の暗黙のアクセスレベルを持つようにする。

### 詳細

このセクションでは、この提案の3つの主要な言語の変更について説明する。

- インポートされたモジュールの可視性を宣言するために、インポート宣言でアクセスレベル修飾子を受け入れること
- ソースファイルを型チェックするときにその情報を適用すること
- 間接的なクライアントが推移的依存関係(transitive dependency)の読み込みをスキップできるかどうかを決定すること

その後、Swift 5とSwift 6のインポートの異なるデフォルトのアクセスレベル、インポートの他の属性との関係もカバーする。

#### インポートされたモジュールのアクセスレベルの宣言

アクセスレベルは、宣言に使用される修飾子(`public`、`package`、`internal`、`fileprivate`、`private`)を使用して、`import`宣言の前に宣言する。

パブリックな依存関係は、どの宣言からも参照することができ、すべてのクライアントから見えるようになる。これは`public`修飾子で宣言されます。

```swift
public import PublicDependency
```

同じパッケージのモジュールにのみ見える依存関係は、`package`修飾子で宣言する。`package`宣言、`internal`宣言、`fileprivate`宣言、`private`宣言のみが、インポートされたモジュールを参照できる。

```swift
package import PackageDependency
```

モジュール内部の依存関係は、`internal`修飾子で宣言する。`internal`、`fileprivate`、`private`宣言のシグネチャのみが、インポートされたモジュールを参照できる。

```swift
internal import InternalDependency
```

このソースファイルに対する`private`依存関係は、`fileprivate`または`private`修飾子で宣言される。どちらの場合も、アクセスはインポートを宣言したソースファイルにスコープされる。インポートされたモジュールを参照できるのは、`fileprivate`宣言と`private`宣言のシグニチャだけである。

```swift
fileprivate import DependencyPrivateToThisFile
private import OtherDependencyPrivateToThisFile
```

`open` アクセスレベル修飾子は、インポート宣言に付与できない。


#### インポートされたモジュールへの参照に対する型チェック

現在の型チェックは、宣言がそれぞれのアクセスレベルを尊重することを強制する。より可視性(visibility)の高い宣言がより低い宣言を参照している場合、エラーとなる。例えば、`public`関数が`internal`型を使用している場合、エラーとなる。

この提案では、インポート宣言のアクセスレベルを、インポートされたソースファイル内のインポート宣言の可視性の上限として使用することで、既存のロジックを拡張する。たとえば、`internal import SomeModule`を持つソースファイルの型チェックを行う場合、`SomeModule`からインポートされたすべての宣言は、そのファイルのコンテキストでアクセスレベルが`internal`であるとみなす。この場合、型チェックでは、`internal`としてインポートされた宣言は、`internal`以下の宣言シグニチャと通常の関数本体からのみ参照されるように強制される。`public`宣言、`@usableFromInline`宣言、または inlinable なコードからは参照できない。これは、現在宣言のアクセスレベル修飾子や inlinable なコードに適用されているおなじみの診断が出力される。

`package`宣言、`fileprivate`宣言、`private import`宣言にも同じロジックを適用する。`public import`の場合、インポートされた宣言がどのように参照されるかは、`public`宣言から参照できないインポートされた`package`宣言に関する既存の制限を超える制限はない。

以下は、`fileprivate`インポートの典型的なケースにおける、型チェックによるおおよその診断の例である。

```swift

fileprivate import DatabaseAdapter

fileprivate func fileprivateFunc() -> DatabaseAdapter.Entry { ... } // Ok

internal func internalFunc() -> DatabaseAdapter.Entry { ... } // error: function cannot be declared internal because its return uses a fileprivate type

public func publicFunc(entry: DatabaseAdapter.Entry) { ... } // error: function cannot be declared public because its parameter uses a fileprivate type

public func useInBody() {
  DatabaseAdapter.create() // Ok
}

@inlinable
public func useInInlinableBody() {
  DatabaseAdapter.create() // error: global function 'create()' is fileprivate and cannot be referenced from an '@inlinable' function
}
```

#### 推移的依存関係のロード

モジュールレベルでこのアクセスレベル情報を使用する場合、依存関係が決して `public import`されず、他の要件が満たされていれば、クライアントから依存関係を隠すことが可能になる。つまりクライアントは、依存関係をロードせずビルドできる。これにより、ビルド時間を短縮し、実装の詳細であるモジュールを配布する必要性をなくせる。

同じ依存関係は、同じモジュールの異なるファイルによって、異なるアクセスレベルでインポートすることができる。モジュールレベルでは、最も寛容なアクセスレベルのみを考慮する。たとえば、ある依存関係が2つの異なるファイルから`package`としても`internal`としてもインポートされた場合、その依存関係はモジュールレベルでは`package`の可視性であるとみなす。

モジュールレベルの情報は、依存関係の推移的なクライアント(transitive clients)に対する異なる動作を意味します。推移的なクライアントとは、その依存関係を間接的にインポートするモジュールのことである。たとえば、以下のシナリオでは、`TransitiveClient`は`ImporterModule`のインポートを介した`IndirectDependency`の推移的クライアントである。

```

module IndirectDependency
         ↑
module MiddleModule
         ↑
module TransitiveClient
```

`IndirectDependency`が`MiddleModule`からどのようにインポートされるかによって、`TransitiveClient`はコンパイル時にそれをロードする必要がある場合とない場合がある。これらのどれにも当てはまらない場合、依存関係を非表示にすることができる。

1. `public`な依存関係は、常に`TransitiveClient`によってロードされなければならない
2. レジリエントではない(Library evolutionがoffの)モジュールのすべての依存関係は、TransitiveClientによってロードされなければならない
3. `package`の依存関係は、`MiddleModule`と`TransitiveClient`が同じパッケージの一部である場合、`TransitiveClient`によってロードされなければならない。これにより、`package`宣言がその依存関係を参照できるようになる。`package`宣言に使われるのと同じロジックを適用して、2つのモジュールのパッケージ名が一致するとき、2つのモジュールは同じパッケージにあるとみなす。
4. すべての依存関係は、`TransitiveClient`が`MiddleModule`を`@testable import`したときにロードされなければならない。`@testable import`のクライアントは、すべてのレベルのインポートの可視性に依存する`internal`宣言を使用できる。`private`や`fileprivate`の依存関係も、レジリエントではない`internal`型のメモリレイアウトに寄与する可能性があるため、ロードする必要がある。

これら4つの要素でカバーされない他のすべてのケースでは、依存関係は非表示であり、`TransitiveClient`によってロードされる必要はないと考える。ただし、同じ依存関係が違うインポートパスではロードされる可能性があることに注意すること。

非表示の依存関係に紐付いたモジュールは、クライアントに配布する必要はない。しかし、モジュールに紐付いたバイナリは、最終的なプログラムを実行するために配布される必要がある。

#### Swift5とSwift6におけるデフォルトのインポートアクセスレベル

明示的なアクセスレベル修飾子なしのデフォルトのインポート宣言のアクセスレベルは、言語バージョンに依存する。ここでは、暗黙のアクセスレベルと、この選択の背後にある理由を列挙する。

Swift5では、インポートはデフォルトで`public`である。これはソースの互換性を維持するためである。Swift5で以前で利用可能だった唯一の公式のインポート(無印の`import`)は、このドキュメントで提案されている`public`インポートのように振る舞う。

Swift6モードでは、インポートはデフォルトで`internal`である。これは、暗黙のアクセスレベルが`internal`である宣言とインポートの振る舞いを一致させる。依存関係を`public`にマークすることは、明示的な修飾子を必要とするので、意図しない依存関係の「つきまとい」を制限するのに役立つはず。

結果として、以下のインポートは Swift5では`public`で、Swift6モードでは`internal`となる。

```swift
import ADependency
```

Swift6の変更は、おそらくライブラリのソースの互換性を壊すだろう。移行ツールは、必要な場所で自動的に`public`修飾子を挿入することができる。ツールが利用できない場合、単純なスクリプトで、すべてのインポートの前に`public`修飾子を挿入することができる。

upcoming flag `InternalImports` は、Swift5を使用しているときでも、Swift6の動作を有効にする。

#### インポート宣言上の他の属性との関係

クライアントがインポートされたモジュール宣言をローカルモジュールの一部であるかのように見るので、`@_exported`属性は`public import`より一歩上になる。この提案では、`@_exported`は、Swift5モードの修飾子またはデフォルトの `public`の可視性(visibility)の両方で、`public import`宣言でのみ受け入れられる。

`@testable`属性は、ローカルモジュールがインポートモジュールの`internal`宣言を参照することを可能する。現在の設計では、インポートされた`internal`型または`package`型を `public`宣言で使用することもできる。アクセスレベルの動作は通常のインポートと同じように適用され、インポートされた宣言はすべてインポート宣言のアクセスレベルを上限とする。`@testable import`の場合、インポートされた`internal`宣言もアクセスレベルの影響を受ける。

現在の`@_implementationOnly import`の使用は、`internal import`よりも下のレベルに置き換えるべきである。比較すると、今回の新機能は、より厳密な型チェックを可能にし、余計な警告を表示することも少なくなる。`internal import`に置き換えた後も、レジリエントなモジュールでは、推移的依存関係のロード要件は変わらないが、レジリエントではないモジュールでは、推移的依存関係のロード要件が変更される。どのような場合でも、`@_implementationOnly`に依存しているモジュールを、代わりに`internal import`を使うように更新することが強く推奨されます。

### ソース互換性

ソースの互換性を保つために、Swift5ではインポートはデフォルトで`public`になる。これは、Swift5でのインポートの現在の動作を維持する。前述したように、Swift6の動作はデフォルト値を変更し、コードの変更が必要になるかもしれない。

### ABI互換性

コンパイル時の型チェックの変更なので影響なし

### 導入の影響

この機能を導入したり、revertしても、注意して使用すればクライアントに影響はないはず。
レジリエントでないモジュールに導入した場合、変更点はモジュールのソースファイルの型チェックのみである。この場合、異なる依存関係のアクセスレベルを変更しても、クライアントには影響しない。
レジリエントでないモジュールに導入する場合、既存のインポートを`public`より低いレベルにマークすることは、クライアントのビルド方法に影響する。コンパイラは、より少ない推移的依存関係をロードすることで、クライアントをビルドすることができます。理論的には、これはクライアントに影響を与えないはずですが、それでもコンパイルの動作が異なる可能性があります。
理論的には、これらの推移的依存関係はクライアントが使用できないので、非表示にしてもクライアントに影響はない。しかし、実際には、推移的依存関係からextensionのメンバの使用を許可する「漏洩」がある。この機能を導入することで、推移的依存関係の読み込みをスキップし、これらの「漏洩」を防ぐことができるかもしれないが、これらの動作に依存しているコードではソースの互換性が壊れる可能性がある。

### 将来の検討事項

#### レジリエントでないモジュールの依存性を隠す

レジリエントでないモジュールの依存性を隠すことは理論的には可能だが、コンパイルプロセスにおけるいくつかの制限を再考する必要がある。主な制限は、コンパイラがインポートされた型のメモリレイアウトを知る必要があることで、これは推移的依存関係に依存する可能性がある。レジリエントなモジュールは、実行時にこの情報を提供することができるので、ビルド時に推移的依存関係は必要ない。レジリエントでないモジュールは実行時にこの情報を提供しないので、コンパイラはビルド時に推移的依存関係をロードしてアクセスしなければならない。解決策としては、各モジュールに必要な情報をコピーするか、依存関係の参照方法をさらに制限することが考えられる。いずれの場合も、それ自体が機能であり、この提案の範囲外。

### 代替案

#### `@_implementationOnly import``

非公式な`@_implementationOnly`属性は、型チェックと推移的依存性の隠蔽の両方で同様の機能を提供する。この属性は、レジリエントでないモジュールから使用されたり、`@testable import`と組み合わされると、不安定になり、実行時にクラッシュする。この属性は、この提案とは少し異なるセマンティックを適用しており、型チェックもそれほど厳密ではない。これは、`public`宣言からのimplementationOnlyインポートモジュールへの参照を報告する独自の型チェックロジックに依存している。対照的に、この提案では既存のアクセスレベルチェックのロジックとセマンティクスを使用している。さらに、この提案では、`private`や`fileprivate`を使ったファイルスコープのインポートや`package`インポートなど、まったく新しい機能が導入されている。

#### `open`インポートを公式の`@_exported`インポートとして使用する

アクセスレベル修飾子`open`は、この提案では特定の意味を割り当てていないため、インポートに使用可能なままである。これを公式の`@_exported`として使用することが提案された。つまり、モジュールのすべてのソースファイルから見えるインポートとしてマークし、同じモジュールの一部であるかのようにクライアントに表示する。私たちは通常、2つのモジュールが同じ名前を共有し、クライアントに統一されたものとして表示することを意図している`clang`モジュールへのSwiftオーバーレイに`@_exported`を使用する。

2つの主な理由が、この変更をこの提案に取り入れることを妨げている:

1. `open`としてマークされた宣言は、モジュールの外からオーバーライドできる。この意味は`@_exported`の動作とは関係ない。他のアクセスレベルは、宣言とインポート宣言の間で対応する意味を持っている
2. この提案の動機は、実装の詳細を隠蔽し、依存関係の「つきまとい」を制限することである。`open import`や`@_exported`の使用を推奨することは、この動機に反するものであり、別の問題に対処するものである。これは、関連する動機を持つ別の提案で議論されるべきである

#### APIでの使用から依存関係の可視性を推論する

モジュールを分析することで、コンパイラは、どの依存関係が`public`宣言で使用され、クライアントに見えるようにする必要があるかを判断できる。そして、他のすべての依存関係を自動的に`internal`依存関係とみなし、他の基準が満たされていれば、間接的なクライアントから非表示にできる。

このアプローチでは、インポート宣言のアクセスレベル修飾子と宣言シグネチャからの参照によって提供される情報の複製が欠けている。この複製は、コンパイラが`import`でマークされた意図を宣言で使用されているものと比較できるようにし、この提案で説明する型チェック動作を可能にする。このチェックは、依存関係が配布されていない場合に重要である。非表示の依存関係から`public`依存関係への変更は、サードパーティが利用できない依存関係として配布されたモジュールを壊す可能性がある。

## 参考リンク

### Forums

- [pitch](https://forums.swift.org/t/pitch-access-level-on-import-statements/66657)
- [review](https://forums.swift.org/t/se-0409-access-level-modifiers-on-import-declarations/67290)

### プロポーザルドキュメント

- [Access-level modifiers on import declarations](https://github.com/apple/swift-evolution/blob/main/proposals/0409-access-level-on-imports.md)