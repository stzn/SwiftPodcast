# Swift Custom Reflection Metadata

- [Swift Custom Reflection Metadata](#swift-custom-reflection-metadata)
  - [概要](#概要)
  - [内容](#内容)
    - [動機](#動機)
    - [提案内容](#提案内容)
    - [詳細](#詳細)
      - [リフレクションメタデータ属性の宣言](#リフレクションメタデータ属性の宣言)
      - [リフレクションメタデータタイプの適用](#リフレクションメタデータタイプの適用)
      - [カスタムリフレクションメタデータの適用に関する制限](#カスタムリフレクションメタデータの適用に関する制限)
      - [リフレクションメタデータ属性の推論](#リフレクションメタデータ属性の推論)
      - [リフレクションによるメタデータへのアクセス](#リフレクションによるメタデータへのアクセス)
      - [APIの利用可能性](#apiの利用可能性)
  - [代替案](#代替案)
    - [他の言語機能の拡張](#他の言語機能の拡張)
    - [init(attachedTo:)シグネチャでリフレクション型を使う](#initattachedtoシグネチャでリフレクション型を使う)
    - [init(attachedTo:)オーバーロードの代わりに静的メソッドを使用する](#initattachedtoオーバーロードの代わりに静的メソッドを使用する)
    - [代替の属性名](#代替の属性名)
    - [@test属性](#test属性)
  - [参考リンク](#参考リンク)
    - [Forums](#forums)
    - [プロポーザルドキュメント](#プロポーザルドキュメント)

## 概要

Swiftでは、宣言は組み込みの言語機能（例：`@available`）とライブラリの機能（例：`@RegexComponentBuilder`）の属性をオプトイン形式でアノテーションすることができる。この提案では、カスタム属性を使用して宣言にライブラリ定義のリフレクションメタデータを付ける機能を導入し、その後、ライブラリの機能にクライアントコードにライブラリの機能をオプトインするために、その属性をライブラリ側で検索できるようにする。

## 内容

### 動機

クライアントに明示的なAPIの呼び出しを要求すると、負担が大きすぎたり、繰り返しが多かったり、忘れやすかったりするので、ライブラリの作者がクライアント自身のコード内に、ライブラリが認識すべき特定の宣言をアノテーションすることが有益な問題領域がいくつか存在する。

1つの典型的な例は**テスト**: ユニットテストライブラリの一般的なパターンがある。ユーザーがライブラリの型の1つを拡張する型を定義し、テストメソッドのいくつかにアノテーションを付ける。そうすることで、ライブラリはすべてのテストを見つけ、それぞれに含まれる型の個別のインスタンスを初期化した後に自動的にすべてのテストを実行する。今日、このテスト発見パターンを実装するためのSwiftの公式なメカニズムはない。しかし、XCTest(言語の現在の事実上の標準テストライブラリ)には、長年使われてきたワークアラウンドがある。

- Appleプラットフォーム上で、XCTestは既知の基本クラスとそれらのメソッドのすべてのサブクラスを列挙するために Objective-Cランタイムに依存し、それは、サポートされているシグネチャと"test"が前に付く名前を持つすべてのインスタンスメソッドをテストメソッドと見なす
- 他のプラットフォームでは、XCTestは通常パッケージから使用され、Swift Package Managerは、ビルド時にインデックスしたデータを検索し、テストメソッドを見つけ、発見したテストのリストをXCTestに明示的に渡して実行するという特別なロジックを持っている

XCTestの現在のアプローチには、いくつかの欠点と制限がある:

- すべてのテストメソッドに "test "というプレフィックスを付けることで、厳密な命名規則を遵守しなければならない。このプレフィックスは、すべてのテストに含まれているため冗長になりがち。また、テスト以外のメソッドで誤ってこのプレフィックスを使ってしまうと、その動作が暗黙のうちに行われてしまうため、ユーザを驚かせてしまう可能性がある
- テストは暗黙のうちに宣言されるので、 個々のテストやテストのグループについての詳細な情報をユーザが提供する方法がない。例えば、あるテストが有効かどうか、その要件、あるいはその他のメタデータを示す方法があれば便利なはず。そうすれば、テストライブラリはこの情報を使ってテストの実行方法を通知し、 より強力な機能を提供できるようになる。
- 組み込みのランタイム検出メカニズムがないため、関連するツール(Swift Package Managerなど)はサポートするそれぞれのテストライブラリに対して、特別な検出ロジックを必要とする。このため、これらのツールに別のテストライブラリのサポートを追加することは非常に難しく、実装が複雑になる

フレームワークによって発見されるコードを登録する一般的なパターンは、Swiftのプログラム全体で共通。例えば、プラグインアーキテクチャを使用するプログラムは、一般的にプラグインのインターフェイスのためのプロトコルを使用し、それは、クライアントで具象型に実装される。このパターンは、フレームワークがその具象型を必要とする前に、クライアントが明示的に具象化したプラグイン型のリストを供給するか、フレームワークによって使用される個々のプラグイン型を明示的に登録しなければならない。これはエラーを起こしやすい登録用のボイラープレートを使うことを強いている。

プログラミング言語のJavaとC#には、それぞれ「Javaアノテーション」「C#アトリビュート」と呼ばれる機能がある。これは、メソッド、変数、パラメータ、そしてJavaの場合はパッケージに属性を追加することができ、Java/C#コンパイラと、実行時にリフレクションAPIを介してアクセスすることができます。私たちは、Swiftに**custom reflection metadata**と呼ばれる同様の追加を提案する。

### 提案内容

- struct、enum、class、およびactorに適用できる新しい組み込み属性`@reflectionMetadata`を追加
- この組み込み属性でアノテーションされた型は、値として使える宣言上のカスタム属性として使用することができる
  - カスタム属性は追加の引数を持つことができる。カスタム属性を適用すると、最初の引数として宣言値を受け取る属性型のイニシャライザの呼び出しに変わる
- カスタム属性が付けられた全ての宣言を収集することができるリフレクションAPIの提供

### 詳細

#### リフレクションメタデータ属性の宣言

リフレクションメタデータカスタム属性は、組み込みの`@reflectionMetadata`属性を名目上の型、すなわち、struct、enum、class、またはactorに付けることによって宣言される

```swift
@reflectionMetadata
struct Example { ... }
```

リフレクションメタデータタイプは`init(attachedTo:)`という形式の同期的に実行されるイニシャライザを持たなければならない。`attachedTo:`パラメータの型は、次の節で説明するように、カスタム属性が適用できる宣言の型を示す。

#### リフレクションメタデータタイプの適用

リフレクションメタデータのカスタム属性は、Swiftの第一級の値として使用できる下記のあらゆる宣言に適用することができる:

- 型
- グローバル関数
- 静的なメソッド
- インスタンスメソッド
- インスタンスプロパティ(可変と不変どちらも)

リフレクションメタデータタイプは`attachedTo:`とラベル付けされたパラメータで始まるイニシャライザのオーバーロードに基づいて、どの種類の宣言がサポートされるかを選ぶことができる。リフレクションメタデータ属性を正しく適用するためには、リフレクションメタデータタイプは最初の引数として適切な値を受け入れるイニシャライザを宣言しなければならない。宣言へのリフレクションメタデータタイプの適用は、属性引数と最初のイニシャライザ引数として渡された宣言値とともにイニシャライザ呼び出しを合成する:

- 型はメタタイプを渡す
- グローバル関数は適用されていない関数参照を渡す
- 型`T`の静的メソッドは、最初の引数として渡されたメタタイプ`T.Type`のメソッドを呼び出す関数を渡す
- 型`T`のインスタンスメソッドは、最初の引数として渡されたインスタンス`T`のメソッドを呼び出す関数を渡す。この関数は、最初の引数が`inout T`で宣言されている場合、`mutating`インスタンスメソッドをサポートする。
- インスタンスプロパティはkey pathを渡す


```swift

@reflectionMetadata
struct Flag {
    // 名目型のメタタイプを受け取るイニシャライザ
    init<T>(attachedTo: T.Type) {
        // ...
    }

    // グローバル関数への未適用の参照を受け取るイニシャライザ
    init<Args, Result>(attachedTo: (Args) -> Result) {
        // ...
    }

    // 静的メソッドを呼び出す関数を受け取るイニシャライザ
    init<T, Args, Result>(attachedTo: (T.Type, Args) -> Result) {
        // ...
    }

    // インスタンスメソッドを呼び出す関数を受け取るイニシャライザ
    init<T, Args, Result>(attachedTo: (T, Args) -> Result) {
        // ...
    }

    // mutatingインスタンスメソッドを呼び出す関数を受け取るイニシャライザ
    init<T, Args, Result>(attachedTo: (inout T, Args) -> Result) {
        // ...
    }

    // インスタンスプロパティへの参照を受け取るイニシャライザ
    init<T, V>(attachedTo: KeyPath<T, V>, custom: Int) {
        // ...
    }
}

// コンパイラは以下のイニシャライザの呼び出しを合成する
// -> Flag.init(attachedTo: doSomething)
@Flag func doSomething(_: Int, other: String) {}

// コンパイラは以下のイニシャライザの呼び出しを合成する
// -> Flag.init(attachedTo: Test.self)
@Flag
struct Test {
    // コンパイラは以下のイニシャライザの呼び出しを合成する
    // -> Flag.init(attachedTo: { metatype in metatype.computeStateless() })
    @Flag static func computeStateless() {}

    // コンパイラは以下のイニシャライザの呼び出しを合成する
    // -> Flag.init(attachedTo: { instance, values in instance.compute(values: values) })
    @Flag func compute(values: [Int]) {}

    var state = 1

    // コンパイラは以下のイニシャライザの呼び出しを合成する
    // -> Flag.init(attachedTo: { (instance: inout Test) in instance.incrementState() })
    @Flag mutating func incrementState() {
        state += 1
    }

    // コンパイラは以下のイニシャライザの呼び出しを合成する
    // -> Flag.init(attachedTo: \Test.answer, custom: 42)
    @Flag(custom: 42) var answer: Int = 42
}
```

#### カスタムリフレクションメタデータの適用に関する制限

宣言は、与えられたリフレクションメタデータタイプが同じ宣言上で一度だけ使われる限り、複数のリフレクションメタデータ属性を持つことができる

```swift
@Flag @Ignore func ignored() { 🟰
  // ...
}

@Flag @Flag func specialFunction() { 🔴 🔴 🔴 🔴
    ^ error: duplicate reflection metadata attribute ．
  // ...
}
```

リフレクションメタデータ属性は、型の主宣言か、型の主宣言と同じモジュール内の型のextensionのどちらかで適用されなければならない。同じ型が複数のリフレクションメタデータアノテーションを持つことを防ぐために、そのモジュール外のextensionで型に属性を適用することは禁止されている

```swift
@Flag extension MyType [where ...] { 🔴
 ^ error: cannot associate reflection metadata @Flag with MyType in extension
}
```

カスタムリフレクションメタデータ属性を持つ宣言は完全な具象型でなければならない。

```swift
struct GenericType<T> {
  @Flag
  var genericValue: T 🔴
  ^ error
}

extension GenericType where T == Int {
  @Flag
  var concreteValue: Int // okay
}
```

Genericな宣言はリフレクションメタデータのすべてのインスタンスを収集するリフレクションAPIのクエリを通して発見することができない。なぜなら、Swiftで高カインドな方法でGenericな値を表現できない。Genericな宣言は将来、他の方向、例えば与えられたキーパス`\Generic<Int>.value`のためのカスタムリフレクションメタデータを返すクエリを追加することによってサポートされるかもしれない。

#### リフレクションメタデータ属性の推論

リフレクションメタデータ属性は、プロトコルに適用することができる:

```swift
@EditorCommandRecord
protocol EditorCommand { /* ... */ }
```

概念的には、リフレクションメタデータ属性は、準拠した具象型を表す一般的な`Self`型に適用される。プロトコルへの準拠が具象型の一次宣言で書かれるとき、リフレクションメタデータ属性は推論される:

```swift
// @EditorCommandRecordが推論される
struct SelectWordCommand: EditorCommand { /* ... */ }
```

プロトコルへの準拠が準拠する型のextensionに書かれている場合，属性の推論は禁止される。プロトコルに適用されるリフレクションメタデータ属性はプロトコルの要求の一形態なので、extensionで宣言されたこのような準拠は、一次宣言がすでに明示的なリフレクションメタデータ属性を持っていない限り無効。

```swift
// 'SelectWordCommand'の一次宣言が'@EditorCommandRecord'を持っていなければエラーとなる
extension SelectWordCommand : EditorCommand { 🔴
   // ...
}
```

プロトコルに適用されるリフレクションメタデータ属性は、追加の属性引数を持つことができない。属性引数は、適合する型に明示的に記述されなければならない。

リフレクションメタデータ属性を持つプロトコルに準拠する型は、明示的にその属性を指定することができる。これは、リフレクションメタデータ型がその`init(attachedTo: ...)`のオーバーロードに追加のパラメータを含む場合、準拠する型がそれらのパラメータのための引数を渡すことを可能にするので、有用なケースがある:

```swift
// `EditorCommand` から推測される `@EditorCommandRecord` 属性をオーバーライドする
@EditorCommandRecord(keyboardShortcut: "j", modifier: .command)
struct SelectWordCommand: EditorCommand { /* ... */ }
```

#### リフレクションによるメタデータへのアクセス

[新しいReflectionモジュール](https://forums.swift.org/t/pitch-reflection/61438)の導入により、そこからこれらの属性を「反射的に」取得するのが自然だと感じている。以下のReflection APIはカスタムリフレクションメタデータのための実行時クエリを提供する:

```swift
/// カスタムリフレクション属性のすべてのインスタンスを、 それがどこに添付されていても取得します
///
/// - Parameters:
///   - type: 様々なソースに付与されている属性のタイプ
/// - Returns: `type`の属性インスタンスを順不同に並べたもの
public enum Attribute {
  public static func allInstances<T>(of type: T.Type) -> AttributeInstances<T>
}

/// いくつかの実行時属性インスタンスに対するSequenceラッパー
///
/// `AttributeInstances`のインスタンスは
/// 以下の `Attribute.allInstances(of:)` 関数で生成される
public struct AttributeInstances<T> {}

extension AttributeInstances: IteratorProtocol {
  @inlinable
  public mutating func next() -> T?
}

extension AttributeInstances: Sequence {}
```

このAPIは、すべてのモジュールにわたってリフレクション属性のすべてのインスタンスを取得する。メタデータタイプのインスタンスは、メタデータを収集するためにリフレクションクエリで初期化されます。現在実行中のOSで利用できない属性、つまり、次のセクションで説明するように`attachedTo`宣言が利用できない属性は、結果から除外される。

#### APIの利用可能性

カスタムメタデータの属性は、利用可能な範囲で宣言に添付することができる。メタデータ属性タイプの個々のインスタンスに対するリフレクションクエリは、一致するAvailabilityによって制限され、実行時に使用できないインスタンスに対しては`nil`を返す。例えば:

```swift
@available(macOS 12, *)
@Flag
struct NewType { /* ... */ }
```

`NewType`に付与された`Flag`インスタンスを生成するリフレクションクエリは、実質的に次のコードを実行することになる:

```swift
if #available(macOS 12, *) {
  return Flag(attachedTo: NewType.self)
} else {
  return nil
}
```
で、`nil`が返されると、`Attribute.allInstances(of:)`が返すコレクションに`NewType`を表す`Flag`インスタンスが含まれないことになる。

## 代替案

### 他の言語機能の拡張

最初のピッチの査読者の中には、リフレクションの機能を向上させ、既存の言語機能を強化することで、動機となる使用事例に対応できるのではと提案する人もいた。例えば:

- 既存のプロトコルに準拠しているというメタデータを使用して、あるプロトコルに準拠するすべての型を検出することができる
- リフレクションでプロパティを発見するために、プロパティラッパを使用することができる

しかし、これらの提案にはいくつかの顕著な欠点がある。*任意の*プロトコルに準拠するすべての型の発見をサポートすることは非常にコストが高く，プロトコルの大部分はこのリフレクション機能を必要としないだろう。必要に応じてプロトコルに付与された属性を通じてこの機能をオプトインすることは，このコストを軽減するという設計の意図的な側面である。

プロトコルに準拠する型を発見することだけを可能にするReflection APIは、リフレクションメタデータに追加のカスタムな値を含むことはできないため，この機能を動機づけるいくつかのユースケースを満たすのに不十分な点に注目することも重要。例えば、上で示された`@EditorCommandRecord(keyboardShortcut: "j", modifier: .command)`の例は、プロトコルに準拠する型にカスタムな値を含んでおり、属性が付与された宣言に加えて、これらの値を取得するリフレクションクエリのための方法も含むように設計されている。プロトコルに準拠する型については，同様の機能がプロトコル要件を通じて提供できるかもしれないが，この方法だと一般化して関数又は計算プロパティにカスタムメタデータを提供することができない。

プロパティのメタデータを表現するためのプロパティラッパの使用について: ラッパは宣言ごとに一定であるにもかかわらず、各インスタンスに対してバッキングプロパティのインスタンスが保存される必要があるため、リフレクションメタデータのツールとしては理想的ではない。リフレクションメタデータのためにだけ使われるプロパティラッパは、ラップされた値へ間接的にアクセスする方法を導入する必要がない。値それ自体は、計算プロパティを合成するのではなく、単に型の中にインラインで格納することができる。

### init(attachedTo:)シグネチャでリフレクション型を使う

リフレクション属性を持つ宣言を表現するために、Reflectionモジュールからの型を使うことを検討した。例えば、`Reflection`の`Field`は、プロパティ宣言にリフレクション属性が付けられるとき、`init(attachedTo:)`の最初のパラメータの型として使えるかもしれない。

しかし、この設計では、 Reflectionの型はそれらが表す宣言のインタフェースの型を公開しないので、イニシャライザの`attachedTo:`の後のジェネリック要件または追加パラメータのような技術を使用して、リフレクション属性が付与された宣言の型を制約することができません。例えば、`Field`はフィールドの型にパラメータ化されていないので、 要件をコンパイル時に強制できない。

### init(attachedTo:)オーバーロードの代わりに静的メソッドを使用する

我々は、メタデータインスタンスを生成するために、リフレクションメタデータタイプの`init(attachedTo:)`のオーバーロードの代わりに`buildMetadata(attachedTo:)`のような静的メソッドを使うことを検討した。これは潜在的に`buildMetadata`のオーバーロードが`Self`と異なる型、またはあるプロトコルから関連する型を返すことができるかもしれません。例えば:

```swift
// 標準ライブラリまたはReflectionで定義されている
protocol Attribute {
  associatedtype Metadata
}

// 使用例
@reflectionMetadata
struct Flag<Metadata>: Attribute {
  static func buildMetadata(attachedTo: ...) -> Metadata { /* ... */ }
}
```

(宣言されたプロパティのすべてのインスタンスに対して一定な)メタデータのためだけに使われる追加のカスタムな値のためのストレージが、それらの値をプロパティラッパのすべてのインスタンスの中に重複して格納するのではなく別々に格納できるため。この代替案は、`@propertyWrapper`型が`@reflectionMetadata`型としても簡単に機能できるようにするという潜在的な利点を持つ。

### 代替の属性名

リフレクションメタデータタイプを宣言するために使われる属性のいくつかの代替的なスペルを検討した:

- @runtimeMetadata
- @dynamicMetadata
- @metadata
- @runtimeAnnotation
- @runtimeAttribute
- @reflectionAnnotation

### @test属性

以前の Swift Evolutionの議論では、[言語に組み込みの`@test`属性を追加する](https://forums.swift.org/t/rfc-in-line-tests/12111)ことが提案された。しかし、「登録」はテストの外でも使われる一般的なコードパターンなので、ライブラリが独自のドメイン固有の属性を宣言できるようにすることは、より広いユースケースのセットをサポートする、より一般的なアプローチとなる。

## 参考リンク

### Forums

- []()

### プロポーザルドキュメント

[Custom Reflection Metadata](https://github.com/apple/swift-evolution/blob/main/proposals/0385-custom-reflection-metadata.md)