# Swift そのasync関数はどのExecutorで動く?

- [Swift そのasync関数はどのExecutorで動く?](#swift-そのasync関数はどのexecutorで動く)
  - [用語](#用語)
  - [概要](#概要)
  - [内容](#内容)
    - [現在の問題点](#現在の問題点)
    - [解決方法](#解決方法)
      - [Sendablity](#sendablity)
    - [ソースで変更が必要な点](#ソースで変更が必要な点)
    - [将来的な検討事項](#将来的な検討事項)
      - [明示的なエグゼキュータの継承](#明示的なエグゼキュータの継承)
      - [エグゼキュータの切り替えの最適化](#エグゼキュータの切り替えの最適化)
      - [`Task`に分離された値と`actor`に分離された値を区別する](#taskに分離された値とactorに分離された値を区別する)
  - [参考リンク](#参考リンク)
    - [Forums](#forums)
    - [プロポーザルドキュメント](#プロポーザルドキュメント)
    - [関連PR](#関連pr)

## 用語

- 分離: `actor`によってデータ競合から守られている(他から分離されている)こと
- エグゼキュータ: async関数を実行するオブジェクト。`actor`は一度に一つの処理を実行するシリアルエグゼキュータを内部に持つ

## 概要

`actor`の`async`関数が`actor`に分離されていることはプロポーザル内でも明記されており、形式的(※)には同じエグゼキュータ上で実行される。しかし`actor`に分離されていない`async`関数に関しては、どのエグゼキュータで実行されるかが明記されていない。このプロポーザルでは、`actor`に分離されていない`async`関数が`actor`のエグゼキュータで実行されないことを明確にし、潜在的なデータ競合を防ぐために`Sendable`チェックをより厳しくする。

※ 形式的と言っているのは内部の最適化の事情で異なる場合もあるらしい。しかし、実際は気にしなくて良い。

## 内容

どのエグゼキュータでコードが実行されるのかを理解することは時々重要になる。`actor`で非常に重い時間のかかる処理を実行すると、`actor`が他のタスクを実行する妨げになる。ある値がデータ競合が起きないように適切に分離されるには、特定のエグゼキュータで実行される必要がある。さらに、ある状況では`Task`のイニシャライザで作成されたタスクから「継承」され、他のセマンティクス上の影響を持つ。そのため、どのエグゼキュータがどのコードを実行するか直感的に理解できるルールを提供する必要がある。

### 現在の問題点

現在の実装では、`actor`に分離されていない`async`関数は、意図的に現在のエグゼキュータを変えることはできない。つまり、その関数の実行に入る時は、常に任意の現在のエグゼキュータで実行される。

もう少し正確に言うと、`async`関数に入るのは、主に下記の3つの方法に分けられる

1. 他の`async`関数から呼ばれる
2. リターンして呼び出し元を再開(resume)する他の`async`関数を呼び出す
3. 内部的な理由(`withContinuation`を使う、または待機が必要なランタイム関数を呼ぶ)で待機(suspend)する必要があり、その後処理を再開する

現在の実装だと、`actor`に分離された関数から呼び出されたり、`actor`に分離された関数からリターンした場合、その`actor`のエグゼキュータで実行が継続する。結果として、事実上`actor`は「くっついた」ままの状態になる。つまり一度タスクが`actor`のエグゼキュータに切り替わると、次の待機が発生するか他の`actor`で処理を実行する必要が出るまで、そのエグゼキュータは占有される。一方で`actor`に分離されていない関数内で他の関数の呼び出しでリターンする以外の理由でタスクが待機した場合、一般的には`actor`以外のエグゼキュータで実行される。

これはエグゼキュータ間の切り替えを最小限にするという観点では納得できるものの、いくつかの残念な結果を招く。

- `actor`のエグゼキュータが本当に必要な後も縛られ続けるため、予期せず余分なハングに繋がる
- `actor`のエグゼキュータはこの余分なハング中にも作成されたタスクから突然継承される(`Task`のイニシャライザから新しい`Task`を作成される)可能性があり、不必要に処理が連続してタスクの順番待ちが発生するかもしれない
- そういった関数の中でどうやって適切に値をデータ競合から守っているのかも不透明(エグゼキュータが動的に決まるので、いくつかのデータは安全にアクセスしているかもしれないが、システムとして保証はできていない)。`actor`のエグゼキュータかもしれないし、他のエグゼキュータかもしれない

### 解決方法

`actor`に分離されていない`async`関数は、形式的には`actor`に関わらない汎用エグゼキュータ上で実行されるべき。そういった関数は`actor`に分離された関数と同じく、関数に入る時、戻り値を返す時、待機から再開する時に、形式的には`actor`ではない汎用エグゼキュータに切り替わるようになる。もしそれまで`actor`のエグゼキュータで実行されていたら、`actor`のエグゼキュータは解放されて他のタスクができるようになる。

```swift
extension MyNetworkSession {
    func readConsistentUpdate() async -> Update {
        // この関数は`actor`に分離されていないため、形式的には呼び出された時に汎用エグゼキュータに切り替わる
        // そのため、`actor`に分離された関数から呼ばれてもここで即座に切り替わる

        // このコードは`actor`に分離されていない

        // 同じ値が2回返るまでreadUpdateを1行づつ呼び続ける
        // 1000回やっても起きなかった場合は最後の値を返す
        var update: Update?
        for i in 0..<1000 {
            // ここでasync呼び出しを行なっている
            let newUpdate = await readUpdateOnce()

            // 形式的には、この呼び出しの後に汎用エグゼキュータに切り替わるので
            // `actor`に分離された関数を呼んだとしてもここで即座に切り替わる

            if update == newUpdate { break }
            update = newUpdate
        }
        return update!
    }
}
```

`actor`に分離されていない`async`関数は、`actor`に関わらない汎用エグゼキュータ上で実行されるように振る舞うことで、そういった関数の解釈を変更する。

この変更によって`async`関数の形式上のエグゼキュータは常に静的にわかるようになる。つまり、

- `actor`に分離された`async`関数は、`actor`のエグゼキュータ上で実行される
- `actor`に分離されていない`async`関数は、形式上`actor`のエグゼキュータ上では**決して実行されない**

また、この変更に応じてタスクは下記のポイントでエグゼキュータの切り替えが要求される

- 関数が呼ばれた時
- 関数によって行われた呼び出しがリターンしたとき
- 関数が内部の待機からリターンしたとき（たとえば、Continuationのため）通常どおり、これらの切り替えは静的および動的な最適化の対象になり、これらの最適化は、`actor`のエグゼキュータへの切り替えですでに行われているものと同じ

ただし、静的な解析時に`actor`に分離されていない`async`関数がリターンや待機、他の`async`関数の呼び出し前に大きい処理を行なっていない場合は、そのまま同じエグゼキュータ上で実行が継続されるし、呼び出し側や再開する側、呼び出された側で、賢明だと判断したらエグゼキュータを切り替えることができる。これが、このプロポーザルで「形式的」にどのエグゼキュータで実行されるかについて話している所以。大抵は気にしないで良いレベルだが、いくつか例外がある。例えば、`actor`のあるメソッドを連続で呼び出した場合、それらの間に他の処理が割って入る可能性がないとは言えない(保証されていない)。

動的にタスクが既に適切なエグゼキュータ上にいる場合は、切り替えによるタスクの待機は発生しない。もっと言うと、エグゼキュータの切り替えは、現在のスレッドを放棄することによるタスクの待機することなしに、より軽量にこれを達成できる場合がある。

#### Sendablity

`actor`に分離されていない`async`関数の`Sendable`ルールは現在壊れている。このルールは、データ競合がないことを証明する際の`Sendable`チェックの役割があるため、これらの関数の実行セマンティクスと密接に関連している。現在のセマンティクスでも壊れているが、今回のプロポーザルのルール下ではおそらくもっと壊れるので、このプロポーザル内で修正をする必要がある。

Swift Concurrencyの基本目標である、プログラム上でデータ競合を起こすべきではない、を達成するために,、ある特定の値とメモリの利用は完全に順序付けられていることを証明できなければならない。つまり、特定のタスクで実行されるすべてのコードは、それ自体に関して完全に順序付けられていなければならない。

`Sendable`という観点では、`actor`に分離された`async`関数の同時並行処理上のコンテキストだと、その`actor`自身になる。`actor`に分離された関数は、そのストレージからローカルの状態(変数など)に値を読み込むことができ、逆にローカルの状態(変数など)からストレージへ書き込みもできる。そのため、「内部」のローカル状態とタスク上の「外部」のローカル状態を厳密に分けなければならない。

現在の`async`呼び出しのルールだと、`actor`に分離された`async`関数の引数や戻り値は、呼び出し側と呼び出し先が同じ`actor`で分離されていない限りは、`Sendable`でなければならないが、`actor`に分離されていない`async`関数にはこのような制限がない。これは現在でも今回のプロポーザルの状況でもローカルの状態が厳密に`actor`に分離されていないため正しくない。

下記のようなことが起きる。

```swift
`actor` MyActor {
    var isolated: NonSendableValue

    // 下記の2つの関数を呼び出す2つの異なるタスクがあり
    // `actor`はinside_one()のタスクを先に呼ぶ状況を想定

    func inside_one() async {
        await outside(argument: isolated)
    }

    func inside_two() async {
        isolated.operate()
    }
}

// これは`actor`に分離されていない`async`関数
func outside(argument: NonSendableValue) async {
    // 現在の実行セマンティクスだと、sleepから再開した際に
    // `actor`のエグゼキュータから離れる

    // 今回のプロポーザルの実行セマンティクスだと、
    // sleepの前に`actor`のエグゼキュータから離れる
    await Task.sleep(nanoseconds: 1_000)

    // いずれにせよ、このnon-Sendableの値は同時並行に`actor`と`actor`外で利用されている
    argument.operate()
}
```

なので、`async`な呼び出しのルールは変更しなければならず、**全ての**`async`な呼び出しの引数と戻り値は`Sendable`でなければならない。

ただし下記は除く。

- 呼び出し側と呼び出し先が同じ`actor`で分離されている
- 呼び出し側と呼び出し先がどちらも`actor`で分離されていない

### ソースで変更が必要な点

実行セマンティクスの変更という点では、ソース上の変更はないが、このプロポーザル後に再コンパイルした時に`actor`に分離された値を、`actor`のエグゼキュータ上からのみアクセス可能な`actor`に分離されていない`async`関数の引数として渡していた場合、データ競合が発生する可能性がある。(少なくともワーニングを出す)

`Sendable`チェックの観点では既にSwift Concurrencyを使用しているコードでsource breakの可能性がある。

どちらにせよ、現在の挙動は望ましくないので変更が必要。既存のコードとの互換性は保たない。

### 将来的な検討事項

#### 明示的なエグゼキュータの継承

`async`関数が呼び出し側からエグゼキュータを動的に継承する余地はあり、シンプルにオプトインする必要がある。しかし喫緊の必要性はない。

`reasync`関数はまだ提案されていないが、`sync`と`async`の境界線を意図的に曖昧にするため、エグゼキュータを継承することはおそらく合理的。

呼び出し側がより強力な`Sendable`ルールを使えるようにしたり、切り替えの静的最適化の過剰な制限を避けたり、もっと効率的なABIをサポートするためには、この種類の継承は呼び出し先の関数シグネチャの一部であるべき。

#### エグゼキュータの切り替えの最適化

`actor`に分離されていない`async`関数に潜在的な切り替えを追加することで、オプティマイザが不必要な切り替えをなくしてくれることがより期待される。待機前のコードが現在のエグゼキュータで実行される必要がないことをプログラマがオプティマイザに明示的に知らせることができる方法が追加されたら良いだろう。

#### `Task`に分離された値と`actor`に分離された値を区別する

ある一つの`Task`、もしくは一つの`actor`からのアクセスのみに制限することで、non-`Sendable`な値の利用は完全に秩序のある状態にすることができる。現在の`Sendable`ルールではこの2つを区別していない。代わりに、関数内の全てのnon-`Sendable`な値は統一的な制約の対象となる。これにより、`actor`に分離された関数と同じ`Task`の他の関数の間に壁ができている。より表現力豊かな`Sendable`ルールがあれば`actor`に分離された`async`関数の中で、これらを区別することができる。これは、このプロポーザルが侵害する合理的な表現度の程度を大幅に減少させることができると考えられる。

引数や戻り値のデフォルトは`actor`に分離されるよりも`Task`に分離されたものでおそらくあるべき。これを検討する場合は最適な結果を得るためにすぐに検討する必要がある。

## 参考リンク

### Forums

- [[Pitch] Clarify the execution of non-`actor`-isolated `async` functions](https://forums.swift.org/t/pitch-clarify-the-execution-of-non-`actor`-isolated-async-functions/54435)

### プロポーザルドキュメント

- [Clarify the Execution of Non-Actor-Isolated Async Functions](https://github.com/apple/swift-evolution/blob/704abec68339ea73b7d4548d44c501a779b8dbb5/proposals/0000-clarify-execution-non-`actor`-async.md)

### 関連PR

- [SE-0338: async functions run on the generic executor](https://github.com/apple/swift/pull/40910)