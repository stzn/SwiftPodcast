# Swift そのasync関数はどのExecutorで動く?

- [Swift そのasync関数はどのExecutorで動く?](#swift-そのasync関数はどのexecutorで動く)
  - [用語](#用語)
  - [概要](#概要)
  - [内容](#内容)
    - [現在の問題点](#現在の問題点)
    - [解決案](#解決案)
      - [Sendablity](#sendablity)
    - [ソース上変更が必要な点](#ソース上変更が必要な点)
    - [将来的な検討事項](#将来的な検討事項)
      - [明示的なエグゼキュータの継承](#明示的なエグゼキュータの継承)
      - [エグゼキュータの切り替えの最適化](#エグゼキュータの切り替えの最適化)
      - [タスク分離とactor分離の値を区別する](#タスク分離とactor分離の値を区別する)
  - [参考リンク](#参考リンク)
    - [Forums](#forums)
    - [プロポーザルドキュメント](#プロポーザルドキュメント)
    - [関連PR](#関連pr)

## 用語

- 分離: actorによってデータ競合から守られている(他から分離されている)状態
- エグゼキュータ: async関数を実行するオブジェクト。actorは内部に一度に一つの処理を実行するシリアルエグゼキュータを持つ

## 概要

actorの`async`関数はactorに分離されていることはプロポーザル内でも明記されており、形式的(※)には同じエグゼキュータ上で実行される。しかしactorに分離されていないasync関数に関しては、どのエグゼキュータで実行されるかが明記されていない。このプロポーザルでは、actorに分離されていない`async`関数がactorのエグゼキュータで実行されないことを明確にし、潜在的なデータ競合を防ぐために`Sendable`チェックをより厳しくする。

※ 形式的と言っているのは内部の最適化の事情で異なる場合もあるらしい。しかし、実際は気にしなくて良い。

## 内容

どのエグゼキュータでコードが実行されるのかを理解することは時々重要になる。actorで非常に重い時間のかかる処理を実行すると、actorが他のタスクを実行する妨げになる。ある値がデータ競合が起きないように適切に分離されるためには、特定のエグゼキュータで実行される必要がある。さらに、ある状況では`Task`のイニシャライザで作成されたタスクから「継承」されるように、他の意味的に影響を持つ。そのため、どのエグゼキュータがどのコードを実行するかの直感的な理解できるルールを提供する必要がある。

### 現在の問題点

現在の実装では、actorに分離されていない`async`関数は、意図的に現在のエグゼキュータを変えることはできない。つまり、その関数の実行に入る時は、常に任意の現在のエグゼキュータで実行される。

もう少し正確に言うと、`async`関数に入るのは、下記の3つの主な方法に分けられる

1. 他の`async`関数から呼ばれる
2. リターンして呼び出し元を再開(resume)する他の`async`関数を呼び出す
3. 内部的な理由(`withContinuation`を使う、または待機が必要なランタイム関数を呼ぶ)で待機(suspend)する必要があり、その後処理を再開する

現在の実装だと、actorに分離された関数から呼び出されたり、actorに分離された関数からリターンした場合、そのactorのエグゼキュータで実行が継続する。結果として、事実上actorは「くっついた」ままの状態になる。つまり一度タスクがactorのエグゼキュータに切り替わると、次の待機が発生するか他のactorで処理を実行する必要が出るまで、そのエグゼキュータは占有される。一方でactorに分離されていない関数内で他の関数の呼び出しでリターンする以外の理由でタスクが待機した場合、一般的にはactor以外のエグゼキュータで実行される。

これはエグゼキュータ間の切り替えを最小限にするという観点では納得できるものの、いくつかの残念な結果を招く。

- actorのエグゼキュータが本当に必要な後も縛られ続けるため、予期せず余分なハングに繋がる
- actorのエグゼキュータはこの余分なハング中にも作成されたタスクから突然継承される可能性があり、不必要に処理が連続してタスクの順番待ちが発生するかもしれない
- そういった関数の中でどうやって適切に値をデータ競合から守っているのかも不透明(エグゼキュータが動的に決まるので、いくつかのデータは安全にアクセスしているかもしれないが、システムとして保証はできていない)

### 解決案

actorに分離されていない`async`関数は、形式的にはactorに関わらない一般的なエグゼキュータ上で実行されるべき。そういった関数はactorに分離された関数と同じく、関数に入る時、戻り値を返す時、待機から再開する時に、形式的には一般的なactorではないエグゼキュータが切り替わるようになる。もしそれまでactorのエグゼキュータで実行されていたら、actorのエグゼキュータは解放されて他のタスクができるようになる。

```swift
extension MyNetworkSession {
    func readConsistentUpdate() async -> Update {
        // この関数はactorに分離されていないため、形式的には呼び出された時に一般的なエグゼキュータに切り替わる
        // そのため、actorに分離された関数から呼ばれてもここで即座に切り替わる

        // このコードはactorに分離されていない

        // 同じ値が2回返るまでreadUpdateを1行づつ呼び続ける
        // 1000回やっても起きなかった場合は最後の値を返す
        var update: Update?
        for i in 0..<1000 {
            // ここでasync呼び出しを行なっている
            let newUpdate = await readUpdateOnce()

            // 形式的には、この呼び出しの後に一般的なエグゼキュータに切り替わるので
            // actorに分離された関数を呼んだとしてもここで即座に切り替わる

            if update == newUpdate { break }
            update = newUpdate
        }
        return update!
    }
}
```

actorに分離されていない`async`関数は、actorに関わらない一般的なエグゼキュータ上で実行されるように振る舞うことで、そういった関数の解釈を変更する。

この変更によって`async`関数の形式上のエグゼキュータは常に静的にわかるようになる。つまり、

- actorに分離された`async`関数は、actorのエグゼキュータ上で実行される
- actorに分離されていない`async`関数は、形式上actorのエグゼキュータ上では**決して実行されない**

また、この変更に応じてタスクは下記のポイントでエグゼキュータの切り替えが要求される

- 関数が呼ばれた時
- 関数によって行われた呼び出しがリターンしたとき
- 関数が内部の待機からリターンしたとき（たとえば、Continuationのため）通常どおり、これらの切り替えは静的および動的な最適化の対象になり、これらの最適化は、actorのエグゼキュータへの切り替えですでに行われているものと同じ。

ただし、静的な解析時にactorに分離されていない`async`関数がリターンや待機、他のasync関数の呼び出し前に大きい処理を行なっていない場合は、そのまま同じエグゼキュータ上で実行が継続されるし、呼び出し側や再開する側、呼び出された側で、賢明だと判断したらエグゼキュータを切り替えることができる。これが、このプロポーザルで「形式的」にどのエグゼキュータで実行されるかについて話している所以。異なる場合がある。大抵は気にしないで良いレベルだが、いくつか例外がある。例えば、actorのあるメソッドを連続で呼び出した場合、それらの間に他の処理が割って入る可能性がないとは言えない(保証されていない)。

動的に、タスクが既に適切なエグゼキュータ上にいる場合は切り替えによるタスクの待機は発生しない。もっと言うと、エグゼキュータの切り替えは、現在のスレッドを放棄することによるタスクの待機することなしに、より軽量にこれを達成できる場合がある。

#### Sendablity

actorに分離されていない`async`関数はの`Sendable`ルールは現在壊れている。このルールは、データ競合がないことを証明する際の`Sendable`チェックの役割があるため、これらの関数の実行セマンティクスと密接に関連している。現在のセマンティクスでも壊れているが、今回のプロポーザルのルール下ではおそらくもっと壊れるので、このプロポーザル内で修正をする必要がある。

Swift Concurrencyの基本目標であるプログラムはデータ競合が起こるべきではない、を達成するためにある特定の値とメモリの利用は完全に順序付けられていることを証明できなければならない。つまり、特定のタスクで実行されるすべてのコードは、それ自体に関して完全に順序付けられていなければならない。

Sendableという観点では、actorに分離された`async`関数の同時並行処理上のコンテキストだとそのactor自身になる。actorに分離された関数はそのストレージからローカルの状態(変数など)に値を読み込むことができ、逆にローカルの状態(変数など)からストレージへ書き込みもできる。そのため、「内部」のローカル状態とタスク上の「外部」のローカル状態を厳密に分けなければならない。

現在の`async`呼び出しのルールだと、actorに分離された`async`関数の引数や戻り値は、呼び出し側と呼び出し先が同じactorで分離されていない限りは、`Sendable`でなければならないが、actorに分離されていない`async`関数にはこのような制限がない。これは現在でも今回のプロポーザルの状況でもローカルの状態が厳密にactorに分離されていないため正しくない。

下記のようなことが起きる。

```swift
actor MyActor {
    var isolated: NonSendableValue

    // 下記の2つの関数を呼び出す2つの異なるタスクがあり
    // actorはinside_one()のタスクを先に呼ぶ状況を想定

    func inside_one() async {
        await outside(argument: isolated)
    }

    func inside_two() async {
        isolated.operate()
    }
}

// これはactorに分離されていない`async`関数
func outside(argument: NonSendableValue) async {
    // 現在の実行セマンティクスだと、sleepから再開した際に
    // actorのエグゼキュータから離れる

    // 今回のプロポーザルの実行セマンティクスだと、
    // sleepの前にactorのエグゼキュータから離れる
    await Task.sleep(nanoseconds: 1_000)

    // いずれにせよ、このnon-Sendableの値は同時並行にactorとactor外で利用されている
    argument.operate()
}
```

なので、`async`呼び出しのルールは変更しなければならず、**全ての**`async`呼び出しの引数と戻り値は`Sendable`でなければならない。

ただし下記は除く。

- 呼び出し側と呼び出し先が同じactorで分離されている
- 呼び出し側と呼び出し先がどちらもactorで分離されていない

### ソース上変更が必要な点

実行セマンティクスの変更という点では、ソース上の変更はないが、このプロポーザル後に再コンパイルした時にactorに分離された値を、actorのエグゼキュータ上からのみアクセスされるactorに分離されていない`async`関数の引数として渡していた場合、データ競合が発生する可能性がある。(少なくともワーニングを出す)

`Sendable`チェックの観点では既にConcurrencyを使用しているコードでsource breakの可能性がある。

どちらにせよ、現在の挙動は望ましくないので変更が必要。既存のコードとの互換性は保たない。

### 将来的な検討事項

#### 明示的なエグゼキュータの継承

`async`関数が呼び出し側からエグゼキュータを動的に継承する余地はあり、シンプルにオプトインする必要がある。しかし喫緊の必要性はない。

`reasync`関数はまだ提案されていないが、`sync`と`async`の境界線を意図的に曖昧にするため、エグゼキュータを継承することはおそらく合理的。

呼び出し側がより強力な`Sendable`ルールを使えるようにしたり、切り替えの静的最適化の過剰な制限を避けたり、もっと効率的なABIをサポートするためには、この種類の継承は呼び出し先の関数シグネチャの一部であるべき。

#### エグゼキュータの切り替えの最適化

actorに分離されていない`async`関数に潜在的な切り替えを追加することで、オプティマイザが不必要な切り替えをなくしてくれることがより期待される。待機前のコードが現在のエグゼキュータで実行される必要がないことをプログラマがオプティマイザに明示的に知らせることができる方法が追加されたら良いだろう。

#### タスク分離とactor分離の値を区別する

ある一つのタスク、もしくは一つのactorからのアクセスのみに制限することで、non-Sendableな値の利用は完全に秩序のある状態にすることができる。現在のSendableルールではこの2つを区別していない。代わりに、関数内の全てのnon-Sendableな値は統一的な制約の対象となる。これにより、actorに分離された関数と同じタスクの他の関数の間に壁が作成できている。より表現力豊かなSendableルールがあればactorに分離された`async`関数の中で、これらを区別することができる。これは、このプロポーザルが侵害する合理的な表現度の程度を大幅に減少させることができると考えられる。

引数や戻り値のデフォルトはactorに分離されるよりもタスクに分離されたものでおそらくあるべき。これを検討する場合は最適な結果を得るためにすぐに検討する必要がある。

## 参考リンク

### Forums

- [[Pitch] Clarify the execution of non-actor-isolated `async` functions](https://forums.swift.org/t/pitch-clarify-the-execution-of-non-actor-isolated-async-functions/54435)

### プロポーザルドキュメント

- [Clarify the Execution of Non-Actor-Isolated Async Functions](https://github.com/apple/swift-evolution/blob/704abec68339ea73b7d4548d44c501a779b8dbb5/proposals/0000-clarify-execution-non-actor-async.md)

### 関連PR

- [SE-0338: async functions run on the generic executor](https://github.com/apple/swift/pull/40910)