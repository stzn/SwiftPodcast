# Swift そのasync関数はどのExecutorで動く?

- [Swift そのasync関数はどのExecutorで動く?](#swift-そのasync関数はどのexecutorで動く)
  - [用語](#用語)
  - [概要](#概要)
  - [内容](#内容)
    - [現在の問題点](#現在の問題点)
    - [解決方法](#解決方法)
      - [Sendablity](#sendablity)
    - [ソースで変更が必要な点](#ソースで変更が必要な点)
    - [将来的な検討事項](#将来的な検討事項)
      - [明示的なエグゼキュータの継承](#明示的なエグゼキュータの継承)
      - [エグゼキュータの切り替えの最適化](#エグゼキュータの切り替えの最適化)
      - [`Task`に分離された値と`actor`に分離された値を区別する](#taskに分離された値とactorに分離された値を区別する)
    - [実装で問題があった？](#実装で問題があった)
  - [参考リンク](#参考リンク)
    - [Forums](#forums)
    - [プロポーザルドキュメント](#プロポーザルドキュメント)
    - [関連PR](#関連pr)

## 用語

- 分離: `actor`によってデータ競合から守られている(他から分離されている)こと
- エグゼキュータ: async関数を実行するオブジェクト。`actor`は一度に一つの処理を実行するシリアルエグゼキュータを内部に持つ

## 概要

`actor`の`async`関数が`actor`に分離されていることはプロポーザル内でも明記されており、形式的(※)には同じエグゼキュータ上で実行される。しかし`actor`に分離されていない`async`関数に関しては、どのエグゼキュータで実行されるかが明記されていない。このプロポーザルでは、`actor`に分離されていない`async`関数が`actor`のエグゼキュータで実行されないことを明確にし、潜在的なデータ競合を防ぐために`Sendable`チェックをより厳しくする。

※ 形式的と言っているのは内部の最適化の事情で異なる場合もあるらしい。しかし、実際は気にしなくて良い。

## 内容

あるコードがどのエグゼキュータで実行されるのかを理解することは重要な時がある。例えば、`actor`で非常に重く時間のかかる処理を実行すると、`actor`が他のタスクを実行する妨げになる。ある値をデータ競合が起きないように適切に分離するには、特定のエグゼキュータ(`actor`のエグゼキュータなど)で実行される必要がある。さらに、ある状況では`Task`のイニシャライザで作成されたタスクから「継承」され、他のセマンティクス上の影響を持つ。そのため、どのエグゼキュータがどのコードを実行するか直感的に理解できるルールを提供する必要がある。

### 現在の問題点

現在の実装では、`actor`に分離されていない`async`関数は、意図的に現在のエグゼキュータを変えることはできない。つまり、その関数の実行に入る時は、常に現在実行している任意のエグゼキュータで実行される。

もう少し正確に言うと、`async`関数に入るのは、主に下記の3つの方法に分けられる

1. 他の`async`関数から呼ばれる
2. リターンして呼び出し元を再開(resume)する他の`async`関数を呼び出す
3. 内部的な理由(`withContinuation`を使う、または待機が必要なランタイム関数を呼ぶ)で待機(suspend)する必要があり、その後処理を再開する

現在の実装だと、`actor`に分離された関数から呼び出されたり、`actor`に分離された関数からリターンした場合、その`actor`のエグゼキュータで実行が継続する。結果として、事実上`actor`は「くっついた」ままの状態になる。つまり一度タスクが`actor`のエグゼキュータに切り替わると、次の待機が発生するか他の`actor`で処理を実行する必要が出るまで、そのエグゼキュータは占有される。一方で`actor`に分離されていない関数内で他の関数の呼び出しでリターンする以外の理由でタスクが待機した場合、一般的には`actor`以外のエグゼキュータで実行される。

これはエグゼキュータ間の切り替えを最小限にするという観点では納得できるものの、いくつかの残念な結果を招く。

- `actor`のエグゼキュータが本当に必要な後も縛られ続けるため、予期せず余分なハングに繋がる
- `actor`のエグゼキュータはこの余分なハング中にも作成されたタスクから突然継承される(`Task`のイニシャライザから新しい`Task`を作成される)可能性があり、不必要に処理が連続してタスクの順番待ちが発生するかもしれない
- そういった関数の中で適切に値をデータ競合から守っている方法が不透明。つまり動的にたまたまその関数を実行しているエグゼキュータがいくつかのデータのアクセスを安全に行っているかもしないが、システムとして保証はおそらくされない。

### 解決方法

`actor`に分離されていない`async`関数は、形式的には`actor`に関わらない汎用エグゼキュータ上で実行されるべき。そういった関数は`actor`に分離された関数と同じく、関数に入る時、戻り値を返す時、待機から再開する時に、形式的には`actor`ではない汎用エグゼキュータに切り替わるようになる。もしそれまで`actor`のエグゼキュータで実行されていたら、`actor`のエグゼキュータは解放されて他のタスクができるようになる。

```swift
extension MyActor {
    func update() async {
      // この関数は`actor`に分離されているため
      // 呼ばれた直後に形式的に`actor`のエグゼキュータに切り替わる

      // ここで`actor`に分離されていないメソッドを呼び出す
      let update = await session.readConsistentUpdate()


      // ここで関数の実行を再開しているため
      // 再び`actor`のエグゼキュータに切り替わる
      name = update.name
      age = update.age
    }
}
extension MyNetworkSession {
    func readConsistentUpdate() async -> Update {
        // この関数は`actor`に分離されていないため、形式的には呼び出された時に汎用エグゼキュータに切り替わる
        // そのため、`actor`に分離された関数から呼ばれてもここで即座に切り替わる

        // このコードは特定の`actor`に分離されずに実行している

        // 同じ値が2回返るまでreadUpdateを1行づつ呼び続ける
        // 1000回やっても起きなかった場合は最後の値を返す
        // ※ 真似しないでください
        var update: Update?
        for i in 0..<1000 {
            // ここでasyncメソッドの呼び出しを行なっている
            let newUpdate = await readUpdateOnce()

            // 形式的には、この呼び出しの後に汎用エグゼキュータに切り替わるので
            // `actor`に分離された関数を呼んだとしてもここで即座に切り替わる

            if update == newUpdate { break }
            update = newUpdate
        }
        return update!
    }
}
```

`actor`に分離されていない`async`関数は、`actor`に関わらない汎用エグゼキュータ上で実行されるように振る舞う。技術的には、現在のルールはどこにも明記されていないので、今回関数にセマンティクスを設定すると言えるが、実際には、挙動に変更が発生する。

この変更によって`async`関数の形式上のエグゼキュータは常に静的にわかるようになる。つまり、

- `actor`に分離された`async`関数は、`actor`のエグゼキュータ上で実行される
- `actor`に分離されていない`async`関数は、形式上`actor`のエグゼキュータ上では**決して実行されない**

また、この変更に応じて、タスクは下記のポイントでエグゼキュータの切り替えが要求される

- ある関数が呼ばれた時
- その関数からの呼び出しが戻ってきた時
- 関数が内部の待機からリターンしたとき（たとえば、continuationによるものなど）。通常どおり、これらの切り替えは静的および動的な最適化の対象になる。これらの最適化は、`actor`のエグゼキュータへの切り替えですでに行われているものと同じ

ただし、静的な解析時に`actor`に分離されていない`async`関数が、リターン前や待機前、他の`async`関数の呼び出し前に大きい処理を行なっていない場合は、そのまま同じエグゼキュータ上で実行が継続され、呼び出し側や再開する側、呼び出された側で、賢明だと判断したらエグゼキュータを切り替えることができる。これが、このプロポーザルで「形式的」にどのエグゼキュータで実行されるかについて話している所以。大抵は気にしないで良いレベルだが、いくつか例外がある。例えば、`actor`のあるメソッドを連続で呼び出した場合、それらの間に他の処理が割って入る可能性がないとは言えない(保証されていない)。

動的にタスクが既に適切なエグゼキュータ上にいる場合は、切り替えによるタスクの待機は発生しない。もっと言うと、エグゼキュータの切り替えは、現在のスレッドを放棄することによるタスクの待機することなしに、より軽量にこれを達成できる場合がある。

#### Sendablity

`actor`に分離されていない`async`関数の現在の`Sendable`チェックルールは壊れている。このルールは、データ競合がないことを証明する際の`Sendable`チェックの役割があるため、これらの関数の実行セマンティクスと密接に関連している。現在のセマンティクスでも壊れているが、今回のプロポーザルのルール下ではおそらくもっと壊れるので、このプロポーザル内で修正をする必要がある。

Swift Concurrencyの基本目標である、プログラム上は基本的なデータ競合から安全であるべき、を達成するために、ある特定の値とメモリの全ての使用は完全に順番通りであることを証明できなければならない。特定のタスクで実行されるすべてのコードは、それ自体に関して完全に順序付けられている。同様に、特定の`actor` で実行されるすべてのコードは、それ自体に関して完全に順序付けられています。つまり、もしある値/メモリを一つのタスクや`actor`に制限することができれば、それらの利用は完全に順番通りであることを証明できる。これが`Sendable`チェックの喫緊の目標である。つまり、non-`Sendable`な値を異なる同時並行処理のコンテキスト間で共有し、潜在的に完全に順番通りではない方法でアクセスされることを防ぐこと。

`Sendable`という観点では、`actor`に分離された`async`関数の同時並行処理上のコンテキストだと、その`actor`自身になる。`actor`に分離された関数は、そのストレージからローカルの状態(変数など)に値を読み込むことができ、逆にローカルの状態(変数など)からストレージへ書き込みもできる。そのため、「内部」のローカル状態とタスク上の「外部」のローカル状態を厳密に分けなければならない。

現在の`async`呼び出しのルールだと、`actor`に分離された`async`関数の引数や戻り値は、呼び出し側と呼び出し先が同じ`actor`で分離されていない限りは、`Sendable`でなければならないが、`actor`に分離されていない`async`関数にはこのような制限がない。これは現在でも、今回のプロポーザルの状況でも、ローカルの状態が厳密に`actor`に分離されていないため正しくない。

下記のようなことが起きる。

```swift
`actor` MyActor {
    var isolated: NonSendableValue

    // 下記の2つの関数を呼び出す2つの異なるタスクがあり
    // `actor`はinside_one()のタスクを先に呼ぶ状況を想定

    func inside_one() async {
        await outside(argument: isolated)
    }

    func inside_two() async {
        isolated.operate()
    }
}

// これは`actor`に分離されていない`async`関数
func outside(argument: NonSendableValue) async {
    // 現在の実行セマンティクスだと、sleepから再開した際に
    // `actor`のエグゼキュータから離れる
    // 今回のプロポーザルの実行セマンティクスだと、
    // sleepの前に`actor`のエグゼキュータから離れる
    await Task.sleep(nanoseconds: 1_000)

    // いずれにせよ、このnon-Sendableの値は同時並行に`actor`と`actor`外で利用されている
    argument.operate()
}
```

なので、`async`の呼び出しのルールを変更しなければならず、**全ての**`async`な呼び出しの引数と戻り値は`Sendable`でなければならない。

ただし下記は除く。

- 呼び出し側と呼び出し先が同じ`actor`で分離されている
- 呼び出し側と呼び出し先がどちらも`actor`で分離されていない

### ソースで変更が必要な点

実行セマンティクスの変更という点でソース上の変更はないが、このプロポーザルに基づいてコードを再コンパイルすると、そのコードが以前は`actor`のエグゼキュータでのみアクセスされる`actor`に分離されていない関数への引数として渡された`actor`に分離された値に依存していた場合、データ競合が発生する可能性がある。(少なくともワーニングがあるはず。)

`Sendable`チェックの観点では既にSwift Concurrencyを使用しているコードでsource breakの可能性がある。

どちらにせよ、現在の挙動は望ましくないので変更が必要。既存のコードとの互換性は保たない。

### 将来的な検討事項

#### 明示的なエグゼキュータの継承

`async`関数が呼び出し側からエグゼキュータを動的に継承する余地はあり、シンプルにオプトインする必要がある。しかし喫緊の必要性はない。

`reasync`関数はまだ提案されていないが、`sync`と`async`の境界線を意図的に曖昧にするので、そういった関数がエグゼキュータを継承することはおそらく合理的である。

呼び出し側がより強力な`Sendable`ルールを使えるようにしたり、切り替えの静的最適化の過剰な制限を避けたり、もっと効率的なABIをサポートするためには、この種類の継承は呼び出し先の関数シグネチャの一部であるべき。

#### エグゼキュータの切り替えの最適化

`actor`に分離されていない`async`関数に潜在的な切り替えを追加することで、オプティマイザが不必要な切り替えをなくしてくれることがより期待される。待機前のコードが現在のエグゼキュータで実行される必要がないことをプログラマがオプティマイザに明示的に知らせることができる方法が追加されたら良いだろう。

#### `Task`に分離された値と`actor`に分離された値を区別する

ある一つの`Task`、もしくは一つの`actor`からのアクセスのみに制限することで、non-`Sendable`な値の利用は完全順番通りにすることができる。現在の`Sendable`ルールではこの2つを区別していない。代わりに、関数内の全てのnon-`Sendable`な値は統一的な制約の対象となる。これにより、`actor`に分離された関数と同じ`Task`の他の関数の間に壁ができている。より厳密な`Sendable`ルールがあれば`actor`に分離された`async`関数の中で、これらを区別することができる。これは、このプロポーザルによって損なわれる機能の程度を大幅に減少させるだろう。

おそらく引数や戻り値のデフォルトは`actor`に分離されるよりも`Task`に分離されたものであるべき。これは最適な結果を得るためにはすぐに検討する必要がある。

### 実装で問題があった？

`with*Continuation`のような標準ライブラリの関数の引数のクロージャは`Sendable`**ではない**。つまり呼び出し側の分離のコンテキストをそのまま継承する。これは望ましい挙動だが、呼び出し側がactorに分離されていた場合、このプロポーザルでは、事実そのクロージャを「送っている」。つまり、これらの関数は`actor`に分離されていない`async`関数と見なされ、汎用エグゼキュータに即座に切り替わり、元のエグゼキュータではなく汎用エグゼキュータ上で実行される。これはプロポーザルの「呼び出し側と同じ方法で分離されていることがわからない限り`async`関数にnon-`Sendable`クロージャを渡せなくする」という`Sendable`ルールで禁止されようとしていた。これはまだ未実装だが、もしこれが実装されると、`actor`に分離されたコンテキストから`with*Continuation`が呼べなくなってしまう。これを修正するには、`with*Continuation`が呼び出し側の分離を継承するようにアノテーションを追加して、non-`Sendable`クロージャを渡せるようにすることと、このクロージャが正しい分離コンテキスト上で実行されることを確証する必要がある。

加えて、このプロポーザルによって、`actor`のアノテーションを正しく追加する新たな圧力をプログラマにかけてしまう。そのため、呼び出し側から`MainActor`を継承することに依存せず、代わりに必要な場所で明示するなど。ただし、Swiftが分離の失敗を確実に診断することでこの問題に終わらせない場合でも、プログラマが適切な`actor`でコードを実行することについて積極的に警戒し続ける必要があるため、これは長期的には明らかに望ましい。


- [[5.6] Revert the partial SE-0338 implementation](https://github.com/apple/swift/pull/41272)

- [Inherit the caller's executor in with*Continuation](https://github.com/apple/swift/pull/41376)

- [Fix and generalize the printing of suppressible features](https://github.com/apple/swift/pull/41399)

## 参考リンク

### Forums

- [[Pitch] Clarify the execution of non-actor-isolated async functions](https://forums.swift.org/t/pitch-clarify-the-execution-of-non-actor-isolated-async-functions/54435)

### プロポーザルドキュメント

- [Clarify the Execution of Non-Actor-Isolated Async Functions](https://github.com/apple/swift-evolution/blob/main/proposals/0338-clarify-execution-non-actor-async.md)

### 関連PR

- [SE-0338: async functions run on the generic executor](https://github.com/apple/swift/pull/40910)