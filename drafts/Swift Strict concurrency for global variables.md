# Swift Strict concurrency for global variables

- [Swift Strict concurrency for global variables](#swift-strict-concurrency-for-global-variables)
  - [概要](#概要)
  - [内容](#内容)
    - [動機](#動機)
    - [プロポーザル](#プロポーザル)
  - [詳細](#詳細)
  - [ソース互換性](#ソース互換性)
  - [ABI 互換性](#abi-互換性)
  - [導入による暗黙の影響](#導入による暗黙の影響)
  - [考慮された代替案](#考慮された代替案)
  - [将来的な方向](#将来的な方向)
  - [参考リンク](#参考リンク)
    - [Forums](#forums)
    - [プロポーザルドキュメント](#プロポーザルドキュメント)


## 概要

このプロポーザルでは、データ競合のないグローバル変数の使用方法を定義する。グローバル変数には、静的な生存時間を持つすべての変数、つまり、グローバルスコープで宣言されるか、静的なメンバ変数として宣言される、`let` 変数や格納変数が含まれる。

## 内容

### 動機

グローバルの状態はどのようなプログラムコンテキストからでもアクセス可能なメモリであるため、同時実行の中で課題となる。グローバル変数は分離を強制する他の試みを無視するため、データが分離されているかをチェックする際は特に注意が必要である。ローカルでキャプチャされていない変数はそのローカルコンテキストからのみアクセスすることができ、暗黙のうちに分離される。値型の格納プロパティは排他ルールによって既に分離されている。参照型の格納プロパティは、そのオブジェクトを含むオブジェクトを `Sendable`で強制的に分離するか、アクターによる制約を使用することで分離できる。しかし、グローバル変数はどこからでもアクセスできるので、これらのツールは機能しない。

```swift

var value = 1

func f() {
  value = 2 // warning: reference to var 'value' is not concurrency-safe because it involves shared mutable state
}
```

### プロポーザル

Strict Concurrencyチェックの下では、すべてのグローバル変数が GlobalActor に分離されているか、下記の両方であることを要求する:

1. 不変
2. `Sendable`

不変かつ `Sendable` なグローバル変数は、どのコンテキストからでも安全にアクセスできる。

トップレベルのグローバル変数は既に `@MainActor` に暗黙的に分離されているため、提案されている要件を自動的に満たしている。

## 詳細

これらの要件は、宣言時に型チェッカーで強制することができる。

グローバル変数は遅延的に初期化されるが、その初期化は既にスレッドセーフであることが保証されているため、Strict Concurrencyチェック下ではそれ以上の指定は必要ない。

データアクセスをシリアライズする大域ロックを使うなど、開発者が行う独自のデータ分離の管理に依存できるようにするために、状況によっては静的チェックをなくす必要があるかもしれない。`nonisolated(unsafe)` 属性を使用すると、グローバル変数(または任意の形式のストレージ)にアノテーションを付けることができる。これはグローバル変数に対するデータ分離の静的チェックを無効するが、データ分離を実現するための同期メカニズムを正しく実装しなければ、排他性の強制やスレッドサニタイザーのようなツールによるランタイム時にしか不正が検知されない可能性があることに注意してほしい。

```swift
nonisolated(unsafe) var global: String
```
ローカル変数に同じアノテーションを付けると、ローカル変数が非同期に参照されたときに静的チェックが生成されないようにできる:

```swift
func f() async {
  nonisolated(unsafe) var value = 1
  let task = Task {
    value = 2
    return value
  }
  print(await task.value)
}
```

`nonisolated`はコンテキスト上のキーワードであるため、スクリプトモードのトップレベル変数の宣言の直前の別の行で`nonisolated(unsafe)`を使用すると、`unsafe`という名前の引数を持つ`nonisolated`という名前の関数の呼び出しにもなりうるため、あいまいになる。このあいまいさは、`unsafe`というラベルのない引数を1つ持ち、変数宣言の前にある場合、`nonisolated`をキーワードとして優先的に解釈することで解決できる。

`@preconcurrency import` を使用してモジュールをインポートすると、明示的なSwift Concurrencyのアノテーションがないインポートされたグローバル変数のデータ分離チェックによる潜在的なエラーが抑制される。`@preconcurrency import`された同時実行時の安全ではないグローバル変数を使用すると、使用時に警告が表示される。

他の言語からのインポートは、暗黙的に`@preconcurrency`であることに注意してほしい。例えば C や Obj-C では `__attribute__((swift_attr("@MainActor")))` を使用してグローバルアクターに分離したり、正しい分離やロックを適切に宣言したより安全な API 内でアクセスをラップしたりする。

## ソース互換性

制限の追加により、Strict Concurrencyが使用されている場合、いくつかの型宣言の変更が必要になる可能性がある。しかし、そのようなソースの変更は、Swift Concurrency 機能を持つ Swift の任意のバージョンとは依然として後方互換性がある。

トップレベルの変数宣言における `nonisolated(unsafe)` のあいまいさを解決するには、変数宣言の直前で、ラベルのない単一の引数 `unsafe` を持つ `nonisolated` という名前の関数を呼び出す既存のトップレベルのスクリプトコードを、データ分離を指定していると解釈することを優先して、その関数の呼び出しを排除することによってソースを壊すことになるだろう。

## ABI 互換性

このプロポーザル自体がABIを追加したり、影響を与えたりすることはないが、このプロポーザルによって採用される可能性のあるプロジェクトのタイプ宣言の変更は、そのプロジェクトのABIに影響を与える可能性がある。

## 導入による暗黙の影響

Strict Concurrency チェックを導入しているプロジェクトでは、いくつかのグローバル変数の型を変更する必要があるかもしれない。

## 考慮された代替案

データ分離のためには、グローバルアクターを必須とするのではなく、変数へのアクセスを暗黙的にロックすることができるかもしれない。しかし、メモリ安全性を提供する一方で、開発者が非アトミックな使用パターンを簡単に書くことができるため、スレッド安全性に問題がある:

```swift
// globalの値は、掛け算掛け算時の読み取りと代入式での値の書き込みの間で同時に変更される可能性がある。
global = global * 2
```

古い言語モードとのソース互換性が必要な場合は、暗黙のロックを考慮できるが、一般的には、古い言語モードは安全に同時実行できないというのが私たちのアプローチである。また、`Sendable` でない型に対しては、その値にアクセスしている間、その値が分離されたままであることを強制しない限り、うまくいかないだろう。提案されている [ドメインの分離を超えてnon Sendableな値を安全に送信する](https://forums.swift.org/t/pitch-safely-sending-non-sendable-values-across-isolation-domains/66566)機能でそれを達成できる可能性はあるが、このような基本的な問題の解決策として推し進めるには高度すぎる機能だろう。

分離を必要とする全てのグローバル変数を`@MainActor`にデフォルト設定することは可能である。しかし、開発者に選択させる方がよいのは間違いないだろう(例えば、単に`let`定数にすべきかもしれません)。

ここではアクセスコントロールは理論上役に立つ。例えば、あるグローバル変数がファイルに対してプライベートであり、そのファイルへはすべて単一のグローバルアクターコンテキストからアクセスされる、あるいはその変数が決して変更されないという理由で、その変数が同時実行内で使用されても安全であると知ることができる。しかし、これは通常コンパイラで行うよりもグローバルな分析である。これを実現する場合、コンテキスト内のすべてをチェックしなければならず、開発者がなぜそれが機能するのかを理解するのは難しいだろう。

## 将来的な方向

グローバルアクターへの分離を明示的に要求する必要は必ずしもない。グローバルアクターに制約された型のグローバルな可変変数は、そのグローバルアクターに制約されていると推論できる(ただし、グローバルアクターに制約されたクラス型はSendableなので、変数が不変であれば不要である)。

## 参考リンク

### Forums

- [[pitch] Strict concurrency for global variables](https://forums.swift.org/t/pitch-strict-concurrency-for-global-variables/66908)
- [SE-0412: Strict concurrency for global variables](https://forums.swift.org/t/se-0412-strict-concurrency-for-global-variables/68352)
- [[Accepted] SE-0412: Strict concurrency for global variables](https://forums.swift.org/t/accepted-se-0412-strict-concurrency-for-global-variables/69004)

### プロポーザルドキュメント

- [Strict concurrency for global variables](https://github.com/apple/swift-evolution/blob/main/proposals/0412-strict-concurrency-for-global-variables.md)