# Swift 複数行クロージャ内の引数と戻り値の型推論

<!-- 最後にTable of Contentsを入れる -->

## 概要

単一行のクロージャとは異なり、複数行に渡るクロージャでは内部から引数や戻り値の情報を外に伝える手段がなく、型推論できずにコンパイルエラーになる。これを改善して推論できるようにする。

## 内容

### 問題点

引数と結果の型は、クロージャを含む式とは別に型チェックされるため、クロージャの本文か周囲のコンテキストに戻る。このようなクロージャ内の情報は、厳密に一方向に流れる。つまり、周囲のコンテキストから本文に流れ、宣言ごとにクロージャの上部から下部に流れます。

単一行のクロージャに新しい式や宣言を追加すると驚くような結果になる。

次の例で考えてみる。

```swift
func map<T>(fn: (Int) -> T) -> T {
    return fn(42)
}

func doSomething<U: BinaryInteger>(_: U) -> Void { /* processing */ }

let _ = map {
    doSomething($0)
}
```

単一行クロージャは、周囲のコンテキストとともに型チェックされるため、`doSomething`の呼び出しの結果の型に基づいて、ジェネリックパラメータ`T`の型を推論することができる。`map`のクロージャの本文で`doSomething`が唯一の呼び出しではない場合、動作は完全に異なる：

```swift
let _ = map {
    logger.info("About to call 'doSomething(\$0)'")
    doSomething($0)
}
```

このクロージャは複数行クロージャと見なされ、現在、型推論の動作は前の例とは異なる。複数行クロージャの本文は、`map`の呼び出しが完全に解決された後に型チェックされる。つまり、ジェネリックパラメータ`T`の型はのいずれかである可能性がある。  

a) まったく決まらない(クロージャの本文に依存するため)  
b) すべての単一行クロージャがデフォルトで設定できる型である`Void`と推論

この場合、開発者の観点から期待される結果はa)、b)のどちらでもないと思われる。a)は`doSomething($0)`が有効な呼び出しなのに、クロージャの戻り値の型が決まらない理由がわからない。b)は`Void`はどこから来たのか、および/またはデフォルトの型が適用されたのかがわからない。ここでのもう1つの角度から見ると、コンパイラの診断です。`map`のクロージャの本文は、別々に型チェックされるため、エラーの正確な原因を特定することができない。もっと言うと、問題の誤った解釈につながる。例えば、`VoidはBinaryIntegerに準拠していない`、またはクロージャの型を明示的に指定するように要求するフォールバック的な診断など。

### 解決策

複数行クロージャが、本文から推論された情報を、それが含まれる式に伝播できるようにする。これにより、セマンティクスが単一行クロージャと統合され、言語からの差異が削除され、引数と戻り値の型推論から意図的な制限が削除される。そして開発者がより良く、より表現力豊かなコードを書く役立つ。

### 詳細

複数行クロージャ推論には、次のセマンティクスがあります。

- 引数と戻り値の型の推論：
    - クロージャのコンテキスト上の型は、その引数と戻り値の型情報の主要なソース
    - コンテキスト情報がない場合、匿名引数への最初の参照が｀コンテキストの中のその型を決める。後続の文が異なる型を生成する場合、そのような状況はあいまいと見なされ、エラーになる。
    - 匿名引数と同様に、最初のreturn文はクロージャの戻り値の型を決める(コンテキスト情報がない場合にのみ推論が行われる)。型チェッカーが異なる型を生成するreturn文に遭遇した場合、そのような状況はエラーとなる
    - クロージャ本文からの`inout`の推論、およびコンテキストへの情報の伝播はサポートされない。`inout`は、引数宣言またはコンテキストの中で型を明示する必要がある。これは、ソースとの互換性影響を与えない現状の動作であり、単一行クロージャの引数の型の推論と矛盾するが、開発者の驚きを最小限にする。この動作を統合する可能性については、将来の検討事項を参照
    - `Void`は、明示的な`return`文のないクロージャのデフォルトの戻り値の型です。
        - 単一行クロージャは、周囲のコンテキストが明示を求めない限り、デフォルトで`Void`に設定できる。例えば、`let _ :　(Int) →Void = { $0 }`。 `return`が明示的でない限り、`let _ :　(Int) →Void = { return $0 }`はエラーになる。

- クロージャの本体は以前と同じように型チェックされ、情報は最初の文から最後の文へと一方向に流れ、情報が逆方向に伝播することはない。
    - このモデルでは、クロージャの推論は他のタイプの宣言(関数、subscript、ゲッタなど)と一致し、宣言から推論された最初の型が事実上の型になるため、重要
    - このプロポーザルでは、単一行クロージャの型チェックは変更されない

先ほどの例を振り返る

```swift
func map<T>(fn: (Int) -> T) -> T {
    return fn(42)
}

func doSomething<U: BinaryInteger>(_: U) -> Void { /* processing */ }

let _ = map {
    doSomething($0)
}
```

新しいセマンティクスでは、`map`のクロージャの本文は正しく型チェックされ、下記のように推論される:

- 匿名引数`$0`は、`doSomething`の呼び出しから期待される引数の型は`Int`になる
- 本文に明示的な`return`文がないため、クロージャの戻り値の型は`Void`になる

新しいセマンティクスを導入したとして、別の例を見てみる:

```swift
struct Box {
    let weight: UInt
}

func heavier_than(boxies: [Box], min: UInt) -> [UInt] {
    let result = boxies.map {
        if $0.weight > min {
            return $0.weight
        }
        return 0
    }
    return result
}
```

現在(新しいセマンティクス以前)、複数行クロージャは式とは別に型チェックされるため、クロージャの戻り値の型を判別することができない。診断では有用なガイダンスも提供できず、クロージャの型を明示的に指定することしか提案されないため、事態はさらに悪化する。

新しいセマンティクスのルールでは、`result`は最初の`return　$0.weight`が`UInt`として推論され、その型情報が次の`return`文の整数リテラル`0`に伝播されるため、戻り値の型は`[UInt]`になる(情報は最初の文から最後の文に流れるため)、その後式に戻る。

これは、次のように、より複雑な式にも適用することができる:

```swift
struct Box {
  let weight: UInt
}

func precisely_between(boxies: [Box], min: UInt, max: UInt) -> [UInt] {
    let result = boxies.map {
        if $0.weight > min {
            return $0.weight
        }

        return 0
    }.filter {
        $0 < max
    }

    return result
}
```

複数行クロージャ(または単にクロージャ)を使用すると、明示的なクロージャの型を常に指定する必要がなくなるため、煩わしさが軽減される。例えば、複数の引数または戻り値の型が複雑なタプルの場合など。

### 型チェックのパフォーマンスへの影響

何年にもわたってこの動作を改善する試みがあった。最新のものは[apple/swift#32223](https://github.com/apple/swift/pull/32223)。関数/subscript/セッタの本文と同様に、複数行クロージャはかなりの行数の文で構成される傾向があり、同じものを効率的に型チェックできないため、それらすべてが型チェッカの内部制限に関連する技術的な問題に遭遇した。単一行クロージャと同じように、「式が複雑すぎる」エラーが発生する。これらの問題は、より段階的なアプローチを採用した新しい実装によって解決されている。

### ソースの互換性

この提案では、単一行クロージャの型チェックのすべての側面がそのまま保持されるため、ソースの互換性への影響はない。

複数行は本文からの引数の型推論をサポートしていないため、型チェックの動作が単一行クロージャとマ複数行クロージャの間で異なる状況が少なくとも1つある。単一行クロージャの引数では型チェックに失敗していたが、複数行クロージャで型チェックされていた式の一部は、使用されているクロージャの型に関係なくあいまいになります。

クロージャを引数に取るオーバーロードされた関数`test`の呼び出しを考えてみる。

```swift
func test<PtrTy, R>(_: (UnsafePointer<PtrTy>) -> R) -> R { ... }
func test<ResultTy>(_: (UnsafeRawBufferPointer) -> ResultTy) -> ResultTy { ... }

let _: Int = test { ptr in
    return Int(ptr[0]) << 2
}
```

現在だと、`test`の呼び出しはあいまい。これは、`PtrTy`が(単一行)クロージャの本文から`Int`であると推論できるため。したがって、`test`の両方のオーバーロードが有効なソリューションを生成する。このクロージャに新しい、おそらく完全に無関係な文を導入した場合、状況は異なる。例:

```swift
func test<PtrTy, R>(_: (UnsafePointer<PtrTy>) -> R) -> R { ... }
func test<ResultTy>(_: (UnsafeRawBufferPointer) -> ResultTy) -> ResultTy { ... }

let _: Int = test { ptr in
    print(ptr) // <-- 本文のセマンティクスに影響を与えるべきではない
    return Int(ptr[0]) << 2
}
```

現在の言語ルールに基づくと、この`test`のこの新しい呼び出しは、複数行クロージャの本文は型チェックに参加しないため、最初のオーバーロードから`PtrTy`を推論する方法がなく、型チェックが通る。プロポーザルのルールでは、型チェッカは、前の単一行クロージャの例と同じように、`return`文に基づいて`PtrTy`が`Int`であると判断できる。つまり、`test`の呼び出しは、`print`の導入前と同じようにあいまいになる。


このような状況を緩和する方法はいくつかある:

- 特別なランキングルールを型チェッカに追加する。これは、引数の型が(完全にまたは部分的に)未解決の引数および/または戻り値の型を持ち、引数が「あまり一般的ではない」型(例: 未解決の戻り値の型のみを持つような)
オーバーロードを選択する複数行クロージャである場合にエラーにすることで既存の挙動を保持する。
- オーバーロードを明確に決定する引数や戻り値の型を指定するようにユーザーに要求する。この例では、`UnsafePointer<Int>`または`UnsafeRawBufferPointer`。
- クロージャの本文から引数や戻り値の型の推論を行わない。これはまさに、現在の複数行クロージャが既存のルールの下で型チェックされる方法であり、制限が厳しすぎる

### 将来の検討事項


#### コンテキストなしでinoutを推論する

単一行クロージャと複数行クロージャの間には矛盾がある-複数行クロージャの本文からの推論と、その逆方向への情報伝播はサポートされておらず、明示的な型アノテーションが必要。 `{（x：inout Int）-> Void in...}`。

現在、`inout`を推論することができるのは:

- 匿名および名前のみの引数のコンテキストの型。例えば、 `[1、2].reduce（into：0）{ $0 + = $1 }`。この場合、`inout`はコンテキストの型(`(inout Result、Self.Element) → Void`)から本文に渡されるため、推論は一方向にのみ行われる。
- 単一行クロージャの場合、本文での使用(代入、演算子、明示的な`＆`を使用した引数の位置)に基づいて、外部の引数の型(クロージャが関連付けられている式に表示される)から推測することができる

2番目の箇条書きであるバックプロパゲーションの動作は、さまざまな種類のクロージャ間で一貫性がありません（単一ステートメントのクロージャでのみ機能します）。 開発者が動作について推論するための視覚的な手がかりがなく、明示的なクロージャタイプを提供することで簡単に修正できるため、これは混乱を招きます。

ソースの互換性への影響が不確実であるため(このような変更が言語にとって合理的であるには影響が大きすぎる可能性ある)、段階的に進歩させるために、このプロポーザルからは分割することは合理的だと考える。この動作を単一行と複数行の間で統合するのは、Swift6で行うかもしれない。そうすることで、ソースの互換性に影響を与えることなくクロージャのエルゴノミクスを改善し、新しい実装を利用して、result builderとコードコンプリーションのパフォーマンスと信頼性を向上させることができる。

### クロージャの本文のreturn文全体で型推論

最初の`guard`文が、プロポーザルのルールの下で推論に役立つのに十分な型情報を提供しない`nil`を返す状況がよくある:

```swift
func test<T>(_: () -> T?) { ... }

test {
    guard let x = doSomething() else {
        return nil // nilからTを推論する十分な情報がない
    }
    ...
}
```

このクロージャを型チェックする唯一の方法は、明示的な型を指定すること(`() -> Int? in ....`)。この状況を改善するために、型チェッカはクロージャの本文の`return`文全体で型推論を可能にできる。つまり、戻り値の実際の型は、`return`文で検出されたすべての型間の結合であり、言語に対して意味的に一意になる。

## 参考リンク

### Forums

- [SE-0326: Multi-statement closure parameter/result type inference](https://forums.swift.org/t/se-0326-multi-statement-closure-parameter-result-type-inference/52964)
- [[Accepted] SE-0326: Multi-statement closure parameter/result type inference](https://forums.swift.org/t/accepted-se-0326-multi-statement-closure-parameter-result-type-inference/53502)

### プロポーザルドキュメント

- [Enable multi-statement closure parameter/result type inference](https://github.com/apple/swift-evolution/blob/main/proposals/0326-extending-multi-statement-closure-inference.md)

### 関連PR

- [[SE-0326] Re-enable multi-statement closure inference by default](https://github.com/apple/swift/pull/41730)