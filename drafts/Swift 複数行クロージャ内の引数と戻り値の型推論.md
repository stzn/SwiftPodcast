# Swift 複数行クロージャ内の引数と戻り値の型推論

- [Swift 複数行クロージャ内の引数と戻り値の型推論](#swift-複数行クロージャ内の引数と戻り値の型推論)
  - [概要](#概要)
  - [内容](#内容)
    - [問題点](#問題点)
    - [解決策](#解決策)
    - [詳細](#詳細)
    - [型チェックのパフォーマンスへの影響](#型チェックのパフォーマンスへの影響)
    - [ソースの互換性](#ソースの互換性)
    - [将来の検討事項](#将来の検討事項)
      - [コンテキストなしでinoutを推論する](#コンテキストなしでinoutを推論する)
    - [クロージャの本文のreturn文全体で型推論](#クロージャの本文のreturn文全体で型推論)
  - [参考リンク](#参考リンク)
    - [Forums](#forums)
    - [プロポーザルドキュメント](#プロポーザルドキュメント)
    - [関連PR](#関連pr)

## 概要

単一行のクロージャとは異なり、複数行に渡るクロージャでは内部から引数や戻り値の情報を外に伝える手段がなく、型推論できずにコンパイルエラーになる。これを改善して推論できるようにする。

## 内容

### 問題点

複数行クロージャは、情報を伝播することができない(例えば、その本文から引数と戻り値の型から周囲のコンテキストに戻るなど)。これは、クロージャ内の式とは別に型チェックされるためである。このようなクロージャ内の情報は、厳密に一方向に流れる。つまり、周囲のコンテキストから本文に流れ、宣言ごとにクロージャの上部から下部に流れる。

そして、単一行のクロージャに新しい式や宣言を追加すると驚くような結果になる。

次の例で考えてみる。

ここからはプロポーザルの内容だと問題を再現できないため、似たようなコードで問題点を挙げる。

<details>
<summary>プロポーザル自体の内容はこちら</summary>

```swift
func map<T>(fn: (Int) -> T) -> T {
    return fn(42)
}

func doSomething(_ v: Int) -> Int { v }

let _ = map {
    doSomething($0)
}
```

単一行クロージャは、周囲のコンテキストとともに型チェックされるため、`doSomething`の呼び出しの結果の型に基づいて、ジェネリックパラメータ`T`の型を推論することができる。しかし、`map`のクロージャの本文で`doSomething`以外にも呼び出しが存在する場合、動作は完全に異なる:

```swift
let _ = map {
    logger.info("About to call 'doSomething\($0)'")
    doSomething($0)
}
```

このクロージャは複数行クロージャと見なされ、現在、型推論の動作は前の例とは異なる。複数行クロージャの本文は、`map`の呼び出しが完全に解決された後に型チェックされる。つまり、ジェネリックパラメータ`T`の型は:  

a) まったく決まらない(クロージャの本文に依存するため)  
b) すべての単一行クロージャのデフォルトの`Void`と推論される

この場合、開発者の観点から期待される結果はa)、b)のどちらでもないと思われる。a)だとすると、`doSomething($0)`が有効な呼び出しなのに、クロージャの戻り値の型が決まらない理由がわからない。b)だとすると、`Void`はどこから来たのか、なぜデフォルトの型が適用されたのかがわからない。ここで、コンパイラの診断というもう1つの角度から見てみると、`map`のクロージャ本文は、別々に型チェックされるため、エラーの正確な原因を特定することもできない。もっと言うと問題の誤った解釈につながる。例えば、`‘Void’ does not conform to ‘BinaryInteger’`、またはクロージャの型を明示的に指定するように要求するフォールバック的な診断など。
</details>

<br/>


```swift
func map<T>(fn: (Int) -> T) -> T {
    return fn(42)
}

func doSomething(_ v: Int) -> Int { v }

let _ = map {
    doSomething($0)
}
```

単一行クロージャは、周囲のコンテキストとともに型チェックされるため、`doSomething`の呼び出しの結果の型に基づいて、ジェネリックパラメータ`T`の型を推論することができる。しかし、`map`のクロージャの本文で`doSomething`以外にも呼び出しが存在する場合、動作は完全に異なる:

```swift
let _ = map { // cannot infer return type for closure with multiple statements; add explicit type to disambiguate
    print("About to call 'doSomething")
    return doSomething($0)
}
```

このクロージャは複数行クロージャと見なされ、現在、型推論の動作は前の例とは異なる。複数行クロージャの本文は、`map`の呼び出しが完全に解決された後に型チェックされる。つまり、ジェネリックパラメータ`T`の型は:  

a) まったく決まらない(クロージャの本文に依存するため)  
b) すべての単一行クロージャのデフォルトの`Void`と推論される

この場合、開発者の観点から期待される結果はa)、b)のどちらでもないと思われる。a)だとすると、`doSomething($0)`が有効な呼び出しなのに、クロージャの戻り値の型が決まらない理由がわからない。b)だとすると、`Void`はどこから来たのか、なぜデフォルトの型が適用されたのかがわからない。ここで、コンパイラの診断というもう1つの角度から見てみると、`map`のクロージャ本文は、別々に型チェックされるため、エラーの正確な原因を特定することもできない。もっと言うと問題の誤った解釈につながる。例えば、`‘Void’ does not conform to ‘BinaryInteger’`、またはクロージャの型を明示的に指定するように要求するフォールバック的な診断など。

実際に出てきているエラーは`cannot infer return type for closure with multiple statements; add explicit type to disambiguate`

### 解決策

複数行クロージャが、本文から推論された情報を、それが周囲に伝播できるようにする。これにより、セマンティクスが単一行クロージャと統合され、言語からの差異や引数と戻り値の型推論の意図的な制限がなくなる。そして開発者がより見通しが良く、より表現力豊かなコードを書くのに役立つ。

### 詳細

複数行クロージャ推論には、次のセマンティクスを持つようになる:

- 引数と戻り値の型の推論：
    - クロージャのコンテキスト上の型は、その引数と戻り値の型情報の主要なソース
    - コンテキスト情報がない場合、匿名引数への最初の参照がコンテキストの中のその型を決める。後続の文が異なる型を生成する場合、そのような状況はあいまいと見なされ、エラーになる。
    - 匿名引数と同様に、最初のreturn文はクロージャの戻り値の型を決める(コンテキスト情報がない場合にのみ推論が行われる)。型チェッカが異なる型を生成するreturn文に遭遇した場合、そのような状況はエラーとなる
    - クロージャ本文からの`inout`の推論、およびコンテキストへの情報の伝播はサポートされない。`inout`は、引数宣言またはコンテキストの中で型を明示する必要がある。これは、ソースとの互換性に影響を与えない現状の動作であり、単一行クロージャの引数の型の推論と矛盾するが、開発者の驚きを最小限にすることができる。この動作を統合する可能性については、[将来の検討事項](#将来の検討事項)を参照。
    - `Void`は、明示的な`return`文のないクロージャのデフォルトの戻り値の型
        - 単一行クロージャの戻り値の型は、周囲のコンテキストが明示を求めない限り、デフォルトで`Void`になる。例えば、`let _ :　(Int) → Void = { $0 }`の`return`が明白でない限り、`let _ :　(Int) → Void = { return $0 }`はエラーになる。

- クロージャ本文内は以前と同じように型チェックされ、情報は最初の文から最後の文へと一方向に流れ、情報が逆方向に伝播することはない。
    - このことは重要で、クロージャの推論が他のタイプの宣言(関数、subscript、ゲッタなど)と一貫することになる。宣言から推論された最初の型が事実上の型になる
    - このプロポーザルでは、単一行クロージャの型チェックに変更はない

先ほどの例を振り返る

```swift
func map<T>(fn: (Int) -> T) -> T {
    return fn(42)
}

func doSomething(_ v: Int) -> Int { v }

let _ = map {
    print("About to call 'doSomething")
    return doSomething($0)
}
```

新しいセマンティクスでは、`map`のクロージャ本文は正しく型チェックされ、下記のように推論される:

- 匿名引数`$0`は、`doSomething`の呼び出しから期待される引数の型は`Int`になる
- クロージャの戻り値の型も`Int`になる

新しいセマンティクスを導入した場合で、別の例を見てみる:

```swift
struct Box {
    let weight: UInt
}

func heavier_than(boxies: [Box], min: UInt) -> [UInt] {
    let result = boxies.map {
        if $0.weight > min {
            return $0.weight
        }
        return 0
    }
    return result
}
```

現在(新しいセマンティクス以前)、複数行クロージャは式とは別に型チェックされるため、クロージャの戻り値の型を判別することができない。コンパイラの診断でも有用なガイダンスを提供できず、クロージャの型を明示的に指定することしか提案されないため、事態はさらに悪化する。

新しいセマンティクスのルールでは、`result`は最初の`return　$0.weight`が`UInt`として推論され、その型情報が次の`return`文の整数リテラル`0`に伝播されるため、戻り値の型は`[UInt]`になる(情報は最初の文から最後の文に流れるため)、その後式に戻る。

これは、次のように、より複雑な式にも適用することができる:

```swift
struct Box {
  let weight: UInt
}

func precisely_between(boxies: [Box], min: UInt, max: UInt) -> [UInt] {
    let result = boxies.map {
        if $0.weight > min {
            return $0.weight
        }

        return 0
    }.filter {
        $0 < max
    }

    return result
}
```

複数行クロージャ(または単にクロージャ)を使用すると、明示的なクロージャの型を常に指定する必要がなくなるため、煩わしさが軽減される。例えば、複数の引数または戻り値の型が複雑なタプルの場合など。

### 型チェックのパフォーマンスへの影響

何年にもわたってこの動作を改善する試みがあった。最新のものは[apple/swift#32223](https://github.com/apple/swift/pull/32223)。関数/subscript/セッタの本文と同様に、複数行クロージャはかなりの行数の文で構成される傾向があり、同じものを効率的に型チェックできないため、それらすべてが型チェッカの内部制限に関連する技術的な問題に遭遇した。単一行クロージャと同じように、「式が複雑すぎる」エラーが発生する。これらの問題は、より段階的なアプローチを採用した新しい実装によって解決されている。

### ソースの互換性

この提案では、単一行クロージャの型チェックのすべての側面がそのまま保持されるため、ソースの互換性への影響はない。

現在、複数行クロージャは本文からの引数の型推論をサポートしていないため、型チェックの動作が単一行クロージャと複数行クロージャの間で異なる状況が少なくとも1つある。これまでは単一行クロージャの引数の型チェックに失敗していたいくつかの式が、複数行クロージャで型チェックされている式の一部は、使用されているクロージャの型に関係なく現在あいまいになってしまうかもしれない。

クロージャを引数に取るオーバーロードされた関数`test`の呼び出しを考えてみる。

```swift
func test<PtrTy, R>(_: (UnsafePointer<PtrTy>) -> R) -> R { ... }
func test<ResultTy>(_: (UnsafeRawBufferPointer) -> ResultTy) -> ResultTy { ... }

let _: Int = test { ptr in
    return Int(ptr[0]) << 2
}
```

現在だと、`test`の呼び出しはあいまい。これは、`PtrTy`が(単一行)クロージャの本文から`Int`であると推論できるため。したがって、`test`の両方のオーバーロードが有効なソリューションを生成する。このクロージャに新しい、おそらく完全に無関係な文を導入した場合、状況は異なる。例:

```swift
func test<PtrTy, R>(_: (UnsafePointer<PtrTy>) -> R) -> R { ... }
func test<ResultTy>(_: (UnsafeRawBufferPointer) -> ResultTy) -> ResultTy { ... }

let _: Int = test { ptr in
    print(ptr) // <-- 本文のセマンティクスに影響を与えるべきではない
    return Int(ptr[0]) << 2
}
```

現在の言語ルールに基づくと、この`test`のこの新しい呼び出しは、複数行クロージャの本文は型チェックに参加しないため、最初のオーバーロードから`PtrTy`を推論する方法がなく、型チェックが通る。プロポーザルのルールでは、型チェッカは、前の単一行クロージャの例と同じように、`return`文に基づいて`PtrTy`が`Int`であると判断できる。つまり、`test`の呼び出しは、`print`の導入前と同じようにあいまいになる。


このような状況を緩和する方法はいくつかある:

- 特別なランキングルールを型チェッカに追加する。これは、引数の型が(完全にまたは部分的に)未解決の引数および/または戻り値の型を持ち、引数が「あまり一般的ではない」型(例: 未解決の戻り値の型のみを持つような)
オーバーロードを選択する複数行クロージャである場合にエラーにすることで既存の挙動を保持する。
- オーバーロードを明確に決定する引数や戻り値の型を指定するようにユーザーに要求する。この例では、`UnsafePointer<Int>`または`UnsafeRawBufferPointer`。
- クロージャの本文から引数や戻り値の型の推論を行わない。これはまさに、現在の複数行クロージャが既存のルールの下で型チェックされる方法であり、制限が厳しすぎる

### 将来の検討事項

#### コンテキストなしでinoutを推論する

単一行クロージャと複数行クロージャの間には矛盾がある-複数行クロージャの本文からの推論と、その逆方向への情報伝播はサポートされておらず、明示的な型アノテーションが必要。 `{（x：inout Int）-> Void in...}`。

現在、`inout`を推論することができるのは:

- 匿名および名前のみの引数のコンテキストの型。例えば、 `[1、2].reduce（into：0）{ $0 + = $1 }`。この場合、`inout`はコンテキストの型(`(inout Result、Self.Element) → Void`)から本文に渡されるため、推論は一方向にのみ行われる。
- 単一行クロージャの場合、本文での使用(代入、演算子、明示的な`＆`を使用した引数の位置)に基づいて、外部の引数の型(クロージャが関連付けられている式に表示される)から推測することができる

2番目の箇条書きであるバックプロパゲーションの動作は、さまざまな種類のクロージャ間で一貫性がありません（単一ステートメントのクロージャでのみ機能します）。 開発者が動作について推論するための視覚的な手がかりがなく、明示的なクロージャタイプを提供することで簡単に修正できるため、これは混乱を招きます。

ソースの互換性への影響が不確実であるため(このような変更が言語にとって合理的であるには影響が大きすぎる可能性ある)、段階的に進歩させるために、このプロポーザルからは分割することは合理的だと考える。この動作を単一行と複数行の間で統合するのは、Swift6で行うかもしれない。そうすることで、ソースの互換性に影響を与えることなくクロージャのエルゴノミクスを改善し、新しい実装を利用して、result builderとコードコンプリーションのパフォーマンスと信頼性を向上させることができる。

### クロージャの本文のreturn文全体で型推論

最初の`guard`文が、プロポーザルのルールの下で推論に役立つのに十分な型情報を提供しない`nil`を返す状況がよくある:

```swift
func test<T>(_: () -> T?) { ... }

test {
    guard let x = doSomething() else {
        return nil // nilからTを推論する十分な情報がない
    }
    ...
}
```

このクロージャを型チェックする唯一の方法は、明示的な型を指定すること(`() -> Int? in ....`)。この状況を改善するために、型チェッカはクロージャの本文の`return`文全体で型推論を可能にできる。つまり、戻り値の実際の型は、`return`文で検出されたすべての型間の結合であり、言語に対して意味的に一意になる。

## 参考リンク

### Forums

- [SE-0326: Multi-statement closure parameter/result type inference](https://forums.swift.org/t/se-0326-multi-statement-closure-parameter-result-type-inference/52964)
- [[Accepted] SE-0326: Multi-statement closure parameter/result type inference](https://forums.swift.org/t/accepted-se-0326-multi-statement-closure-parameter-result-type-inference/53502)

### プロポーザルドキュメント

- [Enable multi-statement closure parameter/result type inference](https://github.com/apple/swift-evolution/blob/main/proposals/0326-extending-multi-statement-closure-inference.md)

### 関連PR

- [[SE-0326] Re-enable multi-statement closure inference by default](https://github.com/apple/swift/pull/41730)